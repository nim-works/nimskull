type
  TRegisterKind* = enum
    rkNone
    rkInt
    rkFloat
    rkAddress ## Register stores an address and optional type. The address is
              ## not required to point to a valid location
    rkLocation ## Register stores an owning handle to a location. Once the
               ## register transitions to a different kind, the location is
               ## cleaned up and the memory freed
    rkHandle ## Register stores a handle to a location

    rkNimNode

  # TODO: reorder the enum fields so that they're either grouped by topic or
  #       usage (or both)
  TOpcode* = enum
    opcEof,         # end of code
    opcRet,         # return
    opcYldYoid,     # yield with no value
    opcYldVal,      # yield with a value

    opcSetEh        # sets the active instruction-to-EH mappings list

    opcAsgnInt,
    opcAsgnFloat,
    opcAsgnComplex,
    opcCastIntToFloat32,    # int and float must be of the same byte size
    opcCastIntToFloat64,    # int and float must be of the same byte size
    opcCastFloatToInt32,    # int and float must be of the same byte size
    opcCastFloatToInt64,    # int and float must be of the same byte size
    opcCastPtrToInt,
    opcCastIntToPtr,
    opcFastAsgnComplex,
    opcNodeToReg,

    opcLdArr,  # a = b[c]
    opcLdArrAddr, # a = addr(b[c])
    opcWrArr,  # a[b] = c
    opcLdObj,  # a = b.c
    opcLdObjAddr, # a = addr(b.c)
    opcWrObj,  # a.b = c
    opcWrLoc,  ## ``a = b``; writes the value represented by register `b`
               ## (either directly or indirectly) to the location identified
               ## by register `a`. A full copy is performed.

    opcAddr,    ## a = addr b
    opcLdDeref,
    opcWrDeref,
    opcWrStrIdx,
    opcLdStrIdx, # a = b[c]; the character is loaded directly into register 'a'

    opcInitDisc # init discriminant (a.b = c)
    opcSetDisc # set discriminant (a.b = c)

    opcWrProc # deref(a) = functions[Bx]

    opcReset   ## resets the memory location referenced by a

    opcAddInt,
    opcAddImmInt,
    opcSubInt,
    opcSubImmInt,
    opcLenSeq,
    opcLenStr,
    opcLenCstring,

    opcIncl, opcInclRange, opcExcl, opcCard, opcMulInt, opcDivInt, opcModInt,
    opcAddFloat, opcSubFloat, opcMulFloat, opcDivFloat,
    opcShrInt, opcShlInt, opcAshrInt,
    opcBitandInt, opcBitorInt, opcBitxorInt, opcAddu, opcSubu, opcMulu,
    opcDivu, opcModu, opcEqInt, opcLeInt, opcLtInt, opcEqFloat,
    opcLeFloat, opcLtFloat, opcLeu, opcLtu,
    opcEqRef, opcEqNimNode, opcSameNodeType,
    opcXor, opcNot, opcUnaryMinusInt, opcUnaryMinusFloat, opcBitnotInt,
    opcEqStr, opcLeStr, opcLtStr, opcEqSet, opcLeSet, opcLtSet,
    opcMulSet, opcPlusSet, opcMinusSet, opcConcatStr,
    opcContainsSet, opcRepr, opcSetLenStr, opcSetLenSeq,
    opcIsNil, opcOf,
    opcParseFloat, opcConv, opcNumConv, opcObjConv, opcCast
    opcQuit, opcInvalidField,
    opcNarrowS, opcNarrowU,
    opcSignExtend,

    opcAddStrCh,
    opcAddStrStr,
    opcAddSeqElem,
    opcRangeChck,
    opcIndexChck, ## abort execution if the index is not in bounds

    opcArrCopy,

    # NimNode manipulation opcodes

    opcNAdd,
    opcNAddMultiple,
    opcNKind,
    opcNSymKind,
    opcNIntVal,
    opcNFloatVal,
    opcNGetType,
    opcNStrVal,
    opcNSigHash,
    opcNGetSize,

    # Direct NimNode setters and NimNode creation

    opcNSetIntVal,
    opcNSetFloatVal, opcNSetStrVal,
    opcNNewNimNode, opcNCopyNimNode, opcNCopyNimTree, opcNDel, opcGenSym,

    # Macro cache operations

    opcNccValue, opcNccInc, opcNcsAdd, opcNcsIncl, opcNcsLen, opcNcsAt,
    opcNctPut, opcNctLen, opcNctGet, opcNctHasNext, opcNctNext, opcNodeId,

    opcParseExprToAst,
    opcParseStmtToAst,
    opcNGetLineInfo, opcNSetLineInfo,
    opcEqIdent,
    opcStrToIdent,
    opcGetImpl,
    opcGetImplTransf,

    opcDataToAst,   ## deserialize data to NimNode AST
    opcExpandToAst,

    opcEcho,
    opcIndCall, # dest = call regStart, n; where regStart = fn, arg1, ...
    opcIndCallAsgn, # dest = call regStart, n; where regStart = fn, arg1, ...

    opcRaise,
    opcNChild,
    opcNSetChild,
    opcCallSite,
    opcNewStr,

    opcTJmp,  # jump Bx if A != 0
    opcFJmp,  # jump Bx if A == 0
    opcJmp,   # jump Bx
    opcJmpBack, # jump Bx; resulting from a while loop
    opcBranch,  # branch for 'case'
    opcEnter, # jump Bx; target must be a ``opcFinally`` instruction
    opcLeave, # if C == 1: abort EH thread associated with finally;
              # if C == 0; abort active EH thread
    opcFinally,
    opcFinallyEnd,
    opcNew,
    opcNewSeq,
    opcLdNull,    # dest = nullvalue(types[Bx])
    opcLdNullReg,
    opcLdConst,   # dest = constants[Bx]
    opcLdGlobal,  # dest = globals[Bx]

    opcLdCmplxConst, # dest = complexConsts[Bx]

    opcLdImmInt,  # dest = immediate value
    opcSetType,   # dest.typ = types[Bx]
    opcObjChck    # raise error if a[] not of types[Bx]
    opcNSetType,  # dest.nimNode.typ = types[Bx]
    opcTypeTrait,
    opcSymOwner,
    opcSymIsInstantiationOf

  AccessViolationReason* = enum
    avrNoError      ## No violation happened
    avrOutOfBounds  ## Access to an address not owned by the VM
    avrTypeMismatch ## Dynamic type is not compatible with static type
    avrNoLocation   ## Address points to valid VM memory. but not to the start
                    ## of a location


const
  firstABxInstr* = opcTJmp
  largeInstrs* = { # instructions which use 2 int32s instead of 1:
    opcConv, opcObjConv, opcCast, opcNewSeq, opcOf}
  relativeJumps* = {opcTJmp, opcFJmp, opcJmp, opcJmpBack, opcEnter, opcFinally}
