#
#
#           The Nim Compiler
#        (c) Copyright 2015 Andreas Rumpf
#
#    See the file "copying.txt", included in this
#    distribution, for details about the copyright.
#

## This module implements the parser of the standard Nim syntax.
## The parser strictly reflects the grammar ("doc/grammar.txt"); however
## it uses several helper routines to keep the parser small. A special
## efficient algorithm is used for the precedence levels. The parser here can
## be seen as a refinement of the grammar, as it specifies how the AST is built
## from the grammar and how comments belong to the AST.


# In fact the grammar is generated from this file:
when isMainModule:
  # Leave a note in grammar.txt that it is generated:
  #| # This file is generated by compiler/parser.nim.
  import pegs
  var outp = open("doc/grammar.txt", fmWrite)
  for line in lines("compiler/parser.nim"):
    if line =~ peg" \s* '#| ' {.*}":
      outp.write matches[0], "\L"
  outp.close

  import "../.." / tools / grammar_nanny
  checkGrammarFile()

import
  compiler/ast/[
    llstream,
    lexer,
    idents,
    ast,
    lineinfos,
    reports
  ],
  std/[
    strutils,
  ],
  compiler/front/[
    msgs,
    options,
  ],
  compiler/utils/[
    pathutils
  ]

when defined(nimpretty):
  import layouter

type
  Parser* = object            # A Parser object represents a file that
                              # is being parsed
    currInd: int              # current indentation level
    firstTok: bool            # Has the first token been read?
    hasProgress: bool         # some while loop requires progress ensurance
    lex*: Lexer               # The lexer that is used for parsing
    tok*: Token               # The current token
    lineStartPrevious*: int
    lineNumberPrevious*: int
    bufposPrevious*: int
    inPragma*: int            # Pragma level
    inSemiStmtList*: int
    emptyNode: PNode
    when defined(nimpretty):
      em*: Emitter

  SymbolMode = enum
    smNormal, smAllowNil, smAfterDot

  PrimaryMode = enum
    pmNormal, pmTypeDesc, pmTypeDef, pmSkipSuffix

proc parseAll*(p: var Parser): PNode
proc closeParser*(p: var Parser)
proc parseTopLevelStmt*(p: var Parser): PNode

# helpers for the other parsers
proc isOperator*(tok: Token): bool
proc getTok*(p: var Parser)
proc skipComment*(p: var Parser, node: PNode)
proc lineInfo*(p: Parser): TLineInfo
proc eat*(p: var Parser, tokType: TokType)
proc skipInd*(p: var Parser)
proc optPar*(p: var Parser)
proc optInd*(p: var Parser, n: PNode)
proc indAndComment*(p: var Parser, n: PNode, maybeMissEquals = false)
proc setBaseFlags*(n: PNode, base: NumericalBase)
proc parseSymbol*(p: var Parser, mode = smNormal): PNode
proc parseTry(p: var Parser; isExpr: bool): PNode
proc parseCase(p: var Parser): PNode
proc parseStmtPragma(p: var Parser): PNode
proc parsePragma(p: var Parser): PNode
proc postExprBlocks(p: var Parser, x: PNode): PNode
proc parseExprStmt(p: var Parser): PNode
proc parseBlock(p: var Parser): PNode
proc primary(p: var Parser, mode: PrimaryMode): PNode
proc simpleExprAux(p: var Parser, limit: int, mode: PrimaryMode): PNode

# implementation

template prettySection(body) =
  when defined(nimpretty): p.em.beginSection
  body
  when defined(nimpretty): p.em.endSection

proc getTok(p: var Parser) =
  ## Get the next token from the parser's lexer, and store it in the parser's
  ## `tok` member.
  p.lineNumberPrevious = p.lex.lineNumber
  p.lineStartPrevious = p.lex.lineStart
  p.bufposPrevious = p.lex.bufpos
  p.lex.rawGetTok(p.tok)
  p.hasProgress = true
  when defined(nimpretty):
    p.em.emitTok(p.lex, p.tok)
    # skip the additional tokens that nimpretty needs but the parser has no
    # interest in:
    while p.tok.tokType == tkComment:
      p.lex.rawGetTok(p.tok)
      p.em.emitTok(p.lex, p.tok)

proc openParser*(p: var Parser, fileIdx: FileIndex, inputStream: PLLStream,
                 cache: IdentCache; config: ConfigRef) =
  ## Open a parser, using the given arguments to set up its internal state.
  ##
  initToken(p.tok)
  openLexer(p.lex, fileIdx, inputStream, cache, config)
  when defined(nimpretty):
    openEmitter(p.em, cache, config, fileIdx)
  p.getTok                   # read the first token
  p.firstTok = true
  p.emptyNode = newNode(nkEmpty)

proc openParser*(p: var Parser, filename: AbsoluteFile, inputStream: PLLStream,
                 cache: IdentCache; config: ConfigRef) =
  openParser(p, fileInfoIdx(config, filename), inputStream, cache, config)

proc closeParser(p: var Parser) =
  ## Close a parser, freeing up its resources.
  closeLexer(p.lex)
  when defined(nimpretty):
    closeEmitter(p.em)


template localError(p: Parser, report: ParserReport): untyped =
  var rep = report
  if rep.found.len == 0:
    rep.found = prettyTok(p.tok)

  p.lex.config.handleReport(
    wrap(rep, instLoc(), p.lex.getLineInfo(p.tok)), instLoc())


template localError(p: Parser, report: ReportTypes): untyped =
  p.lex.config.handleReport(
    wrap(report, instLoc(), p.lex.getLineInfo(p.tok)), instLoc())

template withInd(p, body: untyped) =
  let oldInd = p.currInd
  p.currInd = p.tok.indent
  body
  p.currInd = oldInd

template newlineWasSplitting(p: var Parser) =
  when defined(nimpretty):
    layouter.newlineWasSplitting(p.em)

template realInd(p): bool = p.tok.indent > p.currInd
template sameInd(p): bool = p.tok.indent == p.currInd
template sameOrNoInd(p): bool = p.tok.indent == p.currInd or p.tok.indent < 0

proc validInd(p: var Parser): bool {.inline.} =
  p.tok.indent < 0 or p.tok.indent > p.currInd

proc rawSkipComment(p: var Parser, node: PNode) =
  if p.tok.tokType == tkComment:
    if node != nil:
      var rhs = node.comment
      rhs.add when defined(nimpretty):
                if p.tok.commentOffsetB > p.tok.commentOffsetA:
                  fileSection(p.lex.config, p.lex.fileIdx, p.tok.commentOffsetA, p.tok.commentOffsetB)
                else:
                  p.tok.literal
              else:
                p.tok.literal
      node.comment = move rhs
    else:
      p.localError InternalReport(kind: rintUnreachable, msg: "skipComment")
    p.getTok

proc skipComment(p: var Parser, node: PNode) =
  if p.tok.indent < 0: p.rawSkipComment(node)

proc flexComment(p: var Parser, node: PNode) =
  if p.tok.indent < 0 or p.realInd: p.rawSkipComment(node)

proc skipInd(p: var Parser) =
  if p.tok.indent >= 0:
    if not p.realInd:
      p.localError ParserReport(kind: rparInvalidIndentation)

proc optPar(p: var Parser) =
  if p.tok.indent >= 0:
    if p.tok.indent < p.currInd:
      p.localError ParserReport(kind: rparInvalidIndentation)

proc optInd(p: var Parser, n: PNode) =
  p.skipComment(n)
  p.skipInd

proc getTokNoInd(p: var Parser) =
  p.getTok
  if p.tok.indent >= 0:
    p.localError ParserReport(kind: rparInvalidIndentation)

proc eat(p: var Parser, tokType: TokType) =
  ## Move the parser to the next token if the current token is of type
  ## `tokType`, otherwise error.
  if p.tok.tokType == tokType:
    p.getTok
  else:
    p.localError ParserReport(
      kind: rparUnexpectedToken,
      expected: @[$tokType], found: prettyTok(p.tok))

proc lineInfo(p: Parser): TLineInfo =
  ## Retrieve the line information associated with the parser's current state.
  getLineInfo(p.lex, p.tok)

proc indAndComment(p: var Parser, n: PNode, maybeMissEquals = false) =
  if p.realInd:
    if p.tok.tokType == tkComment: p.rawSkipComment(n)
    elif maybeMissEquals:
      let col = p.bufposPrevious - p.lineStartPrevious
      var info = newLineInfo(p.lex.fileIdx, p.lineNumberPrevious, col)
      p.localError ParserReport(
        kind: rparInvalidIndentation,
        msg: ", maybe you forgot a '=' at $1 ?" % [p.lex.config$info])

    else:
      p.localError ParserReport(kind: rparInvalidIndentation)
  else:
    p.skipComment(n)

proc newNodeP(kind: TNodeKind, p: Parser): PNode =
  newNodeI(kind, p.lineInfo)

proc newIntNodeP(kind: TNodeKind, intVal: BiggestInt, p: Parser): PNode =
  result = newNodeP(kind, p)
  result.intVal = intVal

proc newFloatNodeP(kind: TNodeKind, floatVal: BiggestFloat,
                   p: Parser): PNode =
  result = newNodeP(kind, p)
  result.floatVal = floatVal

proc newStrNodeP(kind: TNodeKind, strVal: string, p: Parser): PNode =
  result = newNodeP(kind, p)
  result.strVal = strVal

proc newIdentNodeP(ident: PIdent, p: Parser): PNode =
  result = newNodeP(nkIdent, p)
  result.ident = ident

proc parseExpr(p: var Parser): PNode
proc parseStmt(p: var Parser): PNode
proc parseTypeDesc(p: var Parser): PNode
proc parseParamList(p: var Parser, retColon = true): PNode

proc isSigilLike(tok: Token): bool {.inline.} =
  tok.tokType == tkOpr and tok.ident.s[0] == '@'

proc isRightAssociative(tok: Token): bool {.inline.} =
  ## Determines whether the token is right assocative.
  tok.tokType == tkOpr and tok.ident.s[0] == '^'
  # or (tok.ident.s.len > 1 and tok.ident.s[^1] == '>')

proc isUnary(tok: Token): bool =
  ## Check if the given token is a unary operator
  tok.tokType in {tkOpr, tkDotDot} and
  tok.strongSpaceB == 0 and tok.strongSpaceA > 0

proc checkBinary(p: Parser) {.inline.} =
  ## Check if the current parser token is a binary operator.
  # we don't check '..' here as that's too annoying
  if p.tok.tokType == tkOpr and
     p.tok.strongSpaceB > 0 and p.tok.strongSpaceA == 0:
    p.localError ParserReport(
      kind: rparInconsistentSpacing, found: prettyTok(p.tok))

#| module = stmt ^* (';' / IND{=})
#|
#| comma = ',' COMMENT?
#| semicolon = ';' COMMENT?
#| colon = ':' COMMENT?
#| colcom = ':' COMMENT?
#|
#| operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
#|          | 'or' | 'xor' | 'and'
#|          | 'is' | 'isnot' | 'in' | 'notin' | 'of' | 'as' | 'from'
#|          | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
#|
#| prefixOperator = operator
#|
#| optInd = COMMENT? IND?
#| optPar = (IND{>} | IND{=})?
#|
#| simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
#| arrowExpr = assignExpr (OP1 optInd assignExpr)*
#| assignExpr = orExpr (OP2 optInd orExpr)*
#| orExpr = andExpr (OP3 optInd andExpr)*
#| andExpr = cmpExpr (OP4 optInd cmpExpr)*
#| cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
#| sliceExpr = ampExpr (OP6 optInd ampExpr)*
#| ampExpr = plusExpr (OP7 optInd plusExpr)*
#| plusExpr = mulExpr (OP8 optInd mulExpr)*
#| mulExpr = dollarExpr (OP9 optInd dollarExpr)*
#| dollarExpr = primary (OP10 optInd primary)*

proc isOperator(tok: Token): bool =
  #| operatorB = OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 |
  #|             'div' | 'mod' | 'shl' | 'shr' | 'in' | 'notin' |
  #|             'is' | 'isnot' | 'not' | 'of' | 'as' | 'from' | '..' | 'and' | 'or' | 'xor'
  tok.tokType in {tkOpr, tkDiv, tkMod, tkShl, tkShr, tkIn, tkNotin, tkIs,
                  tkIsnot, tkNot, tkOf, tkAs, tkFrom, tkDotDot, tkAnd,
                  tkOr, tkXor}

proc colcom(p: var Parser, n: PNode) =
  p.eat(tkColon)
  p.skipComment(n)

const tkBuiltInMagics = {tkType, tkStatic, tkAddr}

proc parseSymbol(p: var Parser, mode = smNormal): PNode =
  #| symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
  #|        | IDENT | KEYW
  case p.tok.tokType
  of tkSymbol:
    result = newIdentNodeP(p.tok.ident, p)
    p.getTok
  of tokKeywordLow..tokKeywordHigh:
    if p.tok.tokType in tkBuiltInMagics or mode == smAfterDot:
      # for backwards compatibility these 2 are always valid:
      result = newIdentNodeP(p.tok.ident, p)
      p.getTok
    elif p.tok.tokType == tkNil and mode == smAllowNil:
      result = newNodeP(nkNilLit, p)
      p.getTok
    else:
      p.localError ParserReport(kind: rparIdentExpected)
      result = p.emptyNode
  of tkAccent:
    result = newNodeP(nkAccQuoted, p)
    p.getTok
    # progress guaranteed
    while true:
      case p.tok.tokType
      of tkAccent:
        if result.len == 0:
          p.localError ParserReport(kind: rparIdentExpected)
        break
      of tkOpr, tkDot, tkDotDot, tkEquals, tkParLe..tkParDotRi:
        let lineinfo = p.lineInfo
        var accm = ""
        while p.tok.tokType in {tkOpr, tkDot, tkDotDot, tkEquals,
                                tkParLe..tkParDotRi}:
          accm.add $p.tok
          p.getTok
        let node = newNodeI(nkIdent, lineinfo)
        node.ident = p.lex.cache.getIdent(accm)
        result.add node 
      of tokKeywordLow..tokKeywordHigh, tkSymbol, tkIntLit..tkCustomLit:
        result.add newIdentNodeP(p.lex.cache.getIdent($p.tok), p)
        p.getTok
      else:
        p.localError ParserReport(kind: rparIdentExpected)
        break
    p.eat(tkAccent)
  else:
    p.localError ParserReport(kind: rparIdentExpected)
    # BUGFIX: We must consume a token here to prevent endless loops!
    # But: this really sucks for idetools and keywords, so we don't do it
    # if it is a keyword:
    #if not isKeyword(p.tok.tokType): p.getTok
    result = p.emptyNode

proc colonOrEquals(p: var Parser, a: PNode): PNode =
  case p.tok.tokType
  of tkColon:
    result = newNodeP(nkExprColonExpr, p)
    p.getTok
    newlineWasSplitting(p)
    #p.optInd(result)
    result.add a
    result.add parseExpr(p)
  of tkEquals:
    result = newNodeP(nkExprEqExpr, p)
    p.getTok
    #p.optInd(result)
    result.add a
    result.add parseExpr(p)
  else:
    result = a

proc exprColonEqExpr(p: var Parser): PNode =
  #| exprColonEqExpr = expr (':'|'=' expr)?
  let a = parseExpr(p)
  if p.tok.tokType == tkDo:
    p.postExprBlocks(a)
  else:
    p.colonOrEquals(a)

proc exprList(p: var Parser, endTok: TokType, result: PNode) =
  #| exprList = expr ^+ comma
  when defined(nimpretty):
    inc p.em.doIndentMore
  p.getTok
  p.optInd(result)
  # progress guaranteed
  while p.tok.tokType notin {endTok, tkEof}:
    var a = parseExpr(p)
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  when defined(nimpretty):
    dec p.em.doIndentMore

proc exprColonEqExprListAux(p: var Parser, endTok: TokType, result: PNode) =
  assert endTok in {tkCurlyRi, tkCurlyDotRi, tkBracketRi, tkParRi}
  p.getTok
  p.flexComment(result)
  p.optPar
  # progress guaranteed
  while p.tok.tokType notin {endTok, tkEof}:
    var a = exprColonEqExpr(p)
    result.add a
    if p.tok.tokType != tkComma: break
    elif result.kind == nkPar:
      result.transitionSonsKind(nkTupleConstr)
    p.getTok
    p.skipComment(a)
  p.optPar
  p.eat(endTok)

proc exprColonEqExprList(p: var Parser, kind: TNodeKind,
                         endTok: TokType): PNode =
  #| exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
  result = newNodeP(kind, p)
  p.exprColonEqExprListAux(endTok, result)

proc dotExpr(p: var Parser, a: PNode): PNode =
  var info = p.lineInfo
  p.getTok
  result = newNodeI(nkDotExpr, info)
  p.optInd(result)
  result.add a
  result.add p.parseSymbol(smAfterDot)
  if p.tok.tokType == tkBracketLeColon and p.tok.strongSpaceA <= 0:
    # rewrite 'x.y[:z]()' to 'y[z](x)'
    var x = newTreeI(nkBracketExpr, p.lineInfo, result[1])
    p.exprList(tkBracketRi, x)
    p.eat(tkBracketRi)
    var y = newTreeI(nkCall, p.lineInfo, [x, result[0]])
    if p.tok.tokType == tkParLe and p.tok.strongSpaceA <= 0:
      p.exprColonEqExprListAux(tkParRi, y)
    result = y

proc dotLikeExpr(p: var Parser, a: PNode): PNode =
  result = newNodeI(nkInfix, p.lineInfo)
  p.optInd(result)
  result.add newIdentNodeP(p.tok.ident, p)
  p.getTok
  result.add a
  result.add p.parseSymbol(smAfterDot)

proc qualifiedIdent(p: var Parser): PNode =
  #| qualifiedIdent = symbol ('.' optInd symbol)?
  result = parseSymbol(p)
  if p.tok.tokType == tkDot:
    result = p.dotExpr(result)

proc setOrTableConstr(p: var Parser): PNode =
  #| setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
  result = newNodeP(nkCurly, p)
  p.getTok # skip '{'
  p.optInd(result)
  if p.tok.tokType == tkColon:
    p.getTok # skip ':'
    result.transitionSonsKind(nkTableConstr)
  else:
    # progress guaranteed
    while p.tok.tokType notin {tkCurlyRi, tkEof}:
      var a = exprColonEqExpr(p)
      if a.kind == nkExprColonExpr: result.transitionSonsKind(nkTableConstr)
      result.add a
      if p.tok.tokType != tkComma: break
      p.getTok
      p.skipComment(a)
  p.optPar
  p.eat(tkCurlyRi) # skip '}'

proc parseCast(p: var Parser): PNode =
  #| castExpr = 'cast' ('[' optInd typeDesc optPar ']' '(' optInd expr optPar ')') /
  #                    ('(' optInd exprColonEqExpr optPar ')')
  result = newNodeP(nkCast, p)
  p.getTok
  if p.tok.tokType == tkBracketLe:
    p.getTok
    p.optInd(result)
    result.add parseTypeDesc(p)
    p.optPar
    p.eat(tkBracketRi)
    p.eat(tkParLe)
    p.optInd(result)
    result.add parseExpr(p)
  else:
    result.add p.emptyNode
    p.eat(tkParLe)
    p.optInd(result)
    result.add exprColonEqExpr(p)
  p.optPar
  p.eat(tkParRi)

proc setBaseFlags(n: PNode, base: NumericalBase) =
  case base
  of base10: discard
  of base2: incl(n.flags, nfBase2)
  of base8: incl(n.flags, nfBase8)
  of base16: incl(n.flags, nfBase16)

proc parseGStrLit(p: var Parser, a: PNode): PNode =
  case p.tok.tokType
  of tkGStrLit:
    result = newNodeP(nkCallStrLit, p)
    result.add a
    result.add newStrNodeP(nkRStrLit, p.tok.literal, p)
    p.getTok
  of tkGTripleStrLit:
    result = newNodeP(nkCallStrLit, p)
    result.add a
    result.add newStrNodeP(nkTripleStrLit, p.tok.literal, p)
    p.getTok
  else:
    result = a

proc complexOrSimpleStmt(p: var Parser): PNode
proc simpleExpr(p: var Parser, mode = pmNormal): PNode
proc parseIfOrWhenExpr(p: var Parser, kind: TNodeKind): PNode

proc semiStmtList(p: var Parser, result: PNode) =
  inc p.inSemiStmtList
  withInd(p):
    # Be lenient with the first stmt/expr
    result.add case p.tok.tokType
               of tkIf: p.parseIfOrWhenExpr(nkIfStmt)
               of tkWhen: p.parseIfOrWhenExpr(nkWhenStmt)
               else: complexOrSimpleStmt(p)

    while p.tok.tokType != tkEof:
      if p.tok.tokType == tkSemiColon:
        p.getTok
      if p.tok.tokType == tkParRi:
        break
      elif not (p.sameInd or p.realInd):
        p.localError ParserReport(kind: rparIdentExpected)
      let a = complexOrSimpleStmt(p)
      if a.kind == nkEmpty:
        p.localError ParserReport(kind: rparExprExpected)
        p.getTok
      else:
        result.add a
  dec p.inSemiStmtList
  result.transitionSonsKind(nkStmtListExpr)

proc parsePar(p: var Parser): PNode =
  #| parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
  #|         | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
  #|         | 'when' | 'var' | 'mixin'
  #| par = '(' optInd
  #|           ( &parKeyw (ifExpr / complexOrSimpleStmt) ^+ ';'
  #|           | ';' (ifExpr / complexOrSimpleStmt) ^+ ';'
  #|           | pragmaStmt
  #|           | simpleExpr ( ('=' expr (';' (ifExpr / complexOrSimpleStmt) ^+ ';' )? )
  #|                        | (':' expr (',' exprColonEqExpr     ^+ ',' )? ) ) )
  #|           optPar ')'
  #
  # unfortunately it's ambiguous: (expr: expr) vs (exprStmt); however a
  # leading ';' could be used to enforce a 'stmt' context ...
  result = newNodeP(nkPar, p)
  p.getTok
  p.optInd(result)
  p.flexComment(result)
  case p.tok.tokType
  of tkDiscard, tkInclude, tkIf, tkWhile, tkCase,
     tkTry, tkDefer, tkFinally, tkExcept, tkBlock,
     tkConst, tkLet, tkWhen, tkVar, tkFor,
     tkMixin:
    # XXX 'bind' used to be an expression, so we exclude it here;
    # tests/reject/tbind2 fails otherwise.
    p.semiStmtList(result)
  of tkSemiColon:
    # '(;' enforces 'stmt' context:
    p.getTok
    p.optInd(result)
    p.semiStmtList(result)
  of tkCurlyDotLe:
    result.add parseStmtPragma(p)
  of tkParRi:
    # Empty tuple '()'
    result.transitionSonsKind(nkTupleConstr)
  else:
    let a = simpleExpr(p)
    case p.tok.tokType
    of tkDo:
      result = p.postExprBlocks(a)
    of tkEquals:
      # special case: allow assignments
      p.getTok
      p.optInd(result)
      let b = parseExpr(p)
      result.add newTreeI(nkAsgn, p.lineInfo, [a, b])
      if p.tok.tokType == tkSemiColon:
        p.semiStmtList(result)
    of tkSemiColon:
      # stmt context:
      result.add a
      p.semiStmtList(result)
    else:
      let a = p.colonOrEquals(a)
      if a.kind == nkExprColonExpr:
        result.transitionSonsKind(nkTupleConstr)
      result.add a
      if p.tok.tokType == tkComma:
        p.getTok
        p.skipComment(a)
        # (1,) produces a tuple expression:
        result.transitionSonsKind(nkTupleConstr)
        # progress guaranteed
        while p.tok.tokType notin {tkParRi, tkEof}:
          var a = exprColonEqExpr(p)
          result.add a
          if p.tok.tokType != tkComma: break
          p.getTok
          p.skipComment(a)
  p.optPar
  p.eat(tkParRi)

proc identOrLiteral(p: var Parser, mode: PrimaryMode): PNode =
  #| literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
  #|           | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
  #|           | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
  #|           | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
  #|           | CHAR_LIT | CUSTOM_NUMERIC_LIT
  #|           | NIL
  #| generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
  #| identOrLiteral = generalizedLit | symbol | literal
  #|                | par | arrayConstr | setOrTableConstr | tupleConstr
  #|                | castExpr
  #| tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
  #| arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
  case p.tok.tokType
  of tkSymbol, tkBuiltInMagics, tkOut:
    result = newIdentNodeP(p.tok.ident, p)
    p.getTok
    result = p.parseGStrLit(result)
  of tkAccent:
    result = parseSymbol(p)       # literals
  of tkIntLit:
    result = newIntNodeP(nkIntLit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkInt8Lit:
    result = newIntNodeP(nkInt8Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkInt16Lit:
    result = newIntNodeP(nkInt16Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkInt32Lit:
    result = newIntNodeP(nkInt32Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkInt64Lit:
    result = newIntNodeP(nkInt64Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkUIntLit:
    result = newIntNodeP(nkUIntLit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkUInt8Lit:
    result = newIntNodeP(nkUInt8Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkUInt16Lit:
    result = newIntNodeP(nkUInt16Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkUInt32Lit:
    result = newIntNodeP(nkUInt32Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkUInt64Lit:
    result = newIntNodeP(nkUInt64Lit, p.tok.iNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkFloatLit:
    result = newFloatNodeP(nkFloatLit, p.tok.fNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkFloat32Lit:
    result = newFloatNodeP(nkFloat32Lit, p.tok.fNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkFloat64Lit:
    result = newFloatNodeP(nkFloat64Lit, p.tok.fNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkFloat128Lit:
    result = newFloatNodeP(nkFloat128Lit, p.tok.fNumber, p)
    setBaseFlags(result, p.tok.base)
    p.getTok
  of tkStrLit:
    result = newStrNodeP(nkStrLit, p.tok.literal, p)
    p.getTok
  of tkRStrLit:
    result = newStrNodeP(nkRStrLit, p.tok.literal, p)
    p.getTok
  of tkTripleStrLit:
    result = newStrNodeP(nkTripleStrLit, p.tok.literal, p)
    p.getTok
  of tkCharLit:
    result = newIntNodeP(nkCharLit, ord(p.tok.literal[0]), p)
    p.getTok
  of tkCustomLit:
    let splitPos = p.tok.iNumber.int
    let str = newStrNodeP(nkRStrLit, p.tok.literal.substr(0, splitPos-1), p)
    let callee = newIdentNodeP(getIdent(p.lex.cache, p.tok.literal.substr(splitPos)), p)
    result = newTreeI(nkDotExpr, p.lineInfo, [str, callee])
    p.getTok
  of tkNil:
    result = newNodeP(nkNilLit, p)
    p.getTok
  of tkParLe:
    # () constructor
    if mode in {pmTypeDesc, pmTypeDef}:
      result = p.exprColonEqExprList(nkPar, tkParRi)
      if result.len == 0: # >0 is handled by exprColonEqExprList
        result.transitionSonsKind(nkTupleConstr)
    else:
      result = parsePar(p)
  of tkCurlyLe:
    # {} constructor
    result = setOrTableConstr(p)
  of tkBracketLe:
    # [] constructor
    result = p.exprColonEqExprList(nkBracket, tkBracketRi)
  of tkCast:
    result = parseCast(p)
  else:
    p.localError ParserReport(kind: rparExprExpected)
    p.getTok  # we must consume a token here to prevent endless loops!
    result = p.emptyNode

proc namedParams(p: var Parser, callee: PNode,
                 kind: TNodeKind, endTok: TokType): PNode =
  # progress guaranteed
  result = newTreeI(kind, p.lineInfo, callee)
  p.exprColonEqExprListAux(endTok, result)

proc commandParam(p: var Parser, isFirstParam: var bool; mode: PrimaryMode): PNode =
  result = if mode == pmTypeDesc:
             p.simpleExpr(mode)
           else:
             parseExpr(p)
  if p.tok.tokType == tkDo:
    result = p.postExprBlocks(result)
  elif p.tok.tokType == tkEquals and not isFirstParam:
    let lhs = result
    result = newNodeP(nkExprEqExpr, p)
    p.getTok
    result.add lhs
    result.add parseExpr(p)
  isFirstParam = false

proc commandExpr(p: var Parser; r: PNode; mode: PrimaryMode): PNode =
  var isFirstParam = true
  # progress NOT guaranteed
  p.hasProgress = false
  newTreeI(nkCommand, p.lineInfo,
    [r, p.commandParam(isFirstParam, mode)])

proc isDotLike(tok: Token): bool =
  tok.tokType == tkOpr and tok.ident.s.len > 1 and
  tok.ident.s[0] == '.' and tok.ident.s[1] != '.'

proc primarySuffix(p: var Parser, r: PNode,
                   baseIndent: int, mode: PrimaryMode): PNode =
  #| primarySuffix = '(' (exprColonEqExpr comma?)* ')'
  #|       | '.' optInd symbol ('[:' exprList ']' ( '(' exprColonEqExpr ')' )?)? generalizedLit?
  #|       | DOTLIKEOP optInd symbol generalizedLit?
  #|       | '[' optInd exprColonEqExprList optPar ']'
  #|       | '{' optInd exprColonEqExprList optPar '}'
  #|       | &( '`'|IDENT|literal|'cast'|'addr'|'type') expr # command syntax
  result = r

  # progress guaranteed
  while p.tok.indent < 0 or
       (p.tok.tokType == tkDot and p.tok.indent >= baseIndent):
    case p.tok.tokType
    of tkParLe:
      # progress guaranteed
      if p.tok.strongSpaceA > 0:
        # inside type sections, expressions such as `ref (int, bar)`
        # are parsed as a nkCommand with a single tuple argument (nkPar)
        result = if mode == pmTypeDef:
                   newTreeI(nkCommand, p.lineInfo,
                     [r, p.primary(pmNormal)])
                 else:
                   p.commandExpr(result, mode)
        break
      else:
        result = p.namedParams(result, nkCall, tkParRi)
        if result.len > 1 and result[1].kind == nkExprColonExpr:
          result.transitionSonsKind(nkObjConstr)
    of tkDot:
      # progress guaranteed
      result = p.parseGStrLit(p.dotExpr(result))
    of tkBracketLe:
      # progress guaranteed
      if p.tok.strongSpaceA > 0:
        result = p.commandExpr(result, mode)
        break
      else:
        result = p.namedParams(result, nkBracketExpr, tkBracketRi)
    of tkCurlyLe:
      # progress guaranteed
      if p.tok.strongSpaceA > 0:
        result = p.commandExpr(result, mode)
        break
      else:
        result = p.namedParams(result, nkCurlyExpr, tkCurlyRi)
    of tkSymbol, tkAccent, tkIntLit..tkCustomLit, tkNil, tkCast,
       tkOpr, tkDotDot, tkVar, tkOut, tkStatic, tkType, tkEnum, tkTuple,
       tkObject, tkProc:
      # XXX: In type sections we allow the free application of the
      # command syntax, with the exception of expressions such as
      # `foo ref` or `foo ptr`. Unfortunately, these two are also
      # used as infix operators for the memory regions feature and
      # the current parsing rules don't play well here.
      let isDotLike2 = p.tok.isDotLike
      if isDotLike2 and p.lex.config.isDefined("nimPreviewDotLikeOps"):
        # synchronize with `tkDot` branch
        result = p.parseGStrLit(p.dotLikeExpr(result))
      else:
        if isDotLike2:
          p.localError ParserReport(kind: rparEnablePreviewDotOps)
        if p.inPragma == 0 and (isUnary(p.tok) or p.tok.tokType notin {tkOpr, tkDotDot}):
          # actually parsing {.push hints:off.} as {.push(hints:off).} is a sweet
          # solution, but pragmas.nim can't handle that
          result = p.commandExpr(result, mode)
        break
    else:
      break

proc parseOperators(p: var Parser, headNode: PNode,
                    limit: int, mode: PrimaryMode): PNode =
  result = headNode
  # expand while operators have priorities higher than 'limit'
  var opPrec = getPrecedence(p.tok)
  let modeB = if mode == pmTypeDef: pmTypeDesc else: mode
  # the operator itself must not start on a new line:
  # progress guaranteed
  while opPrec >= limit and p.tok.indent < 0 and not isUnary(p.tok):
    checkBinary(p)
    let leftAssoc = ord(not isRightAssociative(p.tok))
    var a = newNodeP(nkInfix, p)
    var opNode = newIdentNodeP(p.tok.ident, p) # skip operator:
    p.getTok
    p.flexComment(a)
    p.optPar
    a.add opNode
    a.add result
    # read sub-expression with higher priority:
    a.add p.simpleExprAux(opPrec + leftAssoc, modeB)
    result = a
    opPrec = getPrecedence(p.tok)

proc simpleExprAux(p: var Parser, limit: int, mode: PrimaryMode): PNode =
  result = p.primary(mode)
  if p.tok.tokType == tkCurlyDotLe and p.validInd and mode == pmNormal:
    result = newTreeI(nkPragmaExpr, p.lineInfo,
      [result, p.parsePragma])
  result = p.parseOperators(result, limit, mode)

proc simpleExpr(p: var Parser, mode = pmNormal): PNode =
  when defined(nimpretty):
    inc p.em.doIndentMore
  result = p.simpleExprAux(-1, mode)
  when defined(nimpretty):
    dec p.em.doIndentMore

proc parsePragma(p: var Parser): PNode =
  #| pragma = '{.' optInd (exprColonEqExpr comma?)* optPar ('.}' | '}')
  result = newNodeP(nkPragma, p)
  inc p.inPragma
  when defined(nimpretty):
    inc p.em.doIndentMore
    inc p.em.keepIndents
  p.getTok
  p.optInd(result)
  while p.tok.tokType notin {tkCurlyDotRi, tkCurlyRi, tkEof}:
    p.hasProgress = false
    var a = exprColonEqExpr(p)
    if not p.hasProgress: break
    result.add a
    if p.tok.tokType == tkComma:
      p.getTok
      p.skipComment(a)
  p.optPar
  if p.tok.tokType in {tkCurlyDotRi, tkCurlyRi}:
    when defined(nimpretty):
      if p.tok.tokType == tkCurlyRi: curlyRiWasPragma(p.em)
    p.getTok
  else:
    p.localError ParserReport(
      kind: rparMissingToken, expected: @[".}"], found: $p.tok)
  dec p.inPragma
  when defined(nimpretty):
    dec p.em.doIndentMore
    dec p.em.keepIndents

proc identVis(p: var Parser; allowDot=false): PNode =
  #| identVis = symbol OPR?  # postfix position
  #| identVisDot = symbol '.' optInd symbol OPR?
  let a = parseSymbol(p)
  if p.tok.tokType == tkOpr:
    when defined(nimpretty):
      starWasExportMarker(p.em)
    result = newTreeI(nkPostfix, p.lineInfo,
      [newIdentNodeP(p.tok.ident, p), a])
    p.getTok
  elif p.tok.tokType == tkDot and allowDot:
    result = p.dotExpr(a)
  else:
    result = a

proc identWithPragma(p: var Parser; allowDot=false): PNode =
  #| identWithPragma = identVis pragma?
  #| identWithPragmaDot = identVisDot pragma?
  let a = p.identVis(allowDot)
  if p.tok.tokType == tkCurlyDotLe:
    newTreeI(nkPragmaExpr, p.lineInfo, [a, parsePragma(p)])
  else:
    a

type
  DeclaredIdentFlag = enum
    withPragma,               # identifier may have pragma
    withBothOptional          # both ':' and '=' parts are optional
    withDot                   # allow 'var ident.ident = value'
  DeclaredIdentFlags = set[DeclaredIdentFlag]

proc parseIdentColonEquals(p: var Parser, flags: DeclaredIdentFlags): PNode =
  #| declColonEquals = identWithPragma (comma identWithPragma)* comma?
  #|                   (':' optInd typeDesc)? ('=' optInd expr)?
  #| identColonEquals = IDENT (comma IDENT)* comma?
  #|      (':' optInd typeDesc)? ('=' optInd expr)?)
  var a: PNode
  result = newNodeP(nkIdentDefs, p)
  # progress guaranteed
  while true:
    case p.tok.tokType
    of tkSymbol, tkAccent:
      if withPragma in flags: a = p.identWithPragma(allowDot=withDot in flags)
      else: a = parseSymbol(p)
      if a.kind == nkEmpty: return
    else: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  if p.tok.tokType == tkColon:
    p.getTok
    p.optInd(result)
    result.add parseTypeDesc(p)
  else:
    result.add newNodeP(nkEmpty, p)
    if p.tok.tokType != tkEquals and withBothOptional notin flags:
      p.localError ParserReport(
        kind: rparMissingToken, expected: @[":", "="], found: $p.tok)
  if p.tok.tokType == tkEquals:
    p.getTok
    p.optInd(result)
    result.add parseExpr(p)
  else:
    result.add newNodeP(nkEmpty, p)

proc parseTuple(p: var Parser, indentAllowed = false): PNode =
  #| tupleDecl = 'tuple'
  #|     '[' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']' |
  #|     COMMENT? (IND{>} identColonEquals (IND{=} identColonEquals)*)?
  result = newNodeP(nkTupleTy, p)
  p.getTok
  if p.tok.tokType == tkBracketLe:
    p.getTok
    p.optInd(result)
    # progress guaranteed
    while p.tok.tokType in {tkSymbol, tkAccent}:
      var a = p.parseIdentColonEquals({})
      result.add a
      if p.tok.tokType notin {tkComma, tkSemiColon}: break
      when defined(nimpretty):
        commaWasSemicolon(p.em)
      p.getTok
      p.skipComment(a)
    p.optPar
    p.eat(tkBracketRi)
  elif indentAllowed:
    p.skipComment(result)
    if p.realInd:
      withInd(p):
        p.rawSkipComment(result)
        # progress guaranteed
        while true:
          case p.tok.tokType
          of tkSymbol, tkAccent:
            var a = p.parseIdentColonEquals({})
            if p.tok.indent < 0 or p.tok.indent >= p.currInd:
              p.rawSkipComment(a)
            result.add a
          of tkEof: break
          else:
            p.localError ParserReport(kind: rparIdentExpected, found: $p.tok)
            break
          if not p.sameInd: break
  elif p.tok.tokType == tkParLe:
    p.localError ParserReport(kind: rparTupleTypeWithPar)
  else:
    result = newNodeP(nkTupleClassTy, p)

proc parseParamList(p: var Parser, retColon = true): PNode =
  #| paramList = '(' declColonEquals ^* (comma/semicolon) ')'
  #| paramListArrow = paramList? ('->' optInd typeDesc)?
  #| paramListColon = paramList? (':' optInd typeDesc)?
  result = newNodeP(nkFormalParams, p)
  result.add p.emptyNode # return type
  when defined(nimpretty):
    inc p.em.doIndentMore
    inc p.em.keepIndents
  let hasParLe = p.tok.tokType == tkParLe and p.tok.indent < 0
  if hasParLe:
    p.getTok
    p.optInd(result)
    # progress guaranteed
    var a: PNode
    while true:
      case p.tok.tokType
      of tkSymbol, tkAccent:
        a = p.parseIdentColonEquals({withBothOptional, withPragma})
      of tkParRi:
        break
      of tkVar:
        p.localError ParserReport(kind: rparMisplacedParameterVar)
        break
      else:
        p.localError ParserReport(
          kind: rparMissingToken, found: $p.tok, expected: @[")"])
        break
      result.add a
      if p.tok.tokType notin {tkComma, tkSemiColon}: break
      when defined(nimpretty):
        commaWasSemicolon(p.em)
      p.getTok
      p.skipComment(a)
    p.optPar
    p.eat(tkParRi)
  let hasRet = retColon and p.tok.tokType == tkColon or
               p.tok.tokType == tkOpr and p.tok.ident.s == "->"
  if hasRet and p.tok.indent < 0:
    p.getTok
    p.optInd(result)
    result[0] = parseTypeDesc(p)
  elif not retColon and not hasParLe:
    # Mark as "not there" in order to mark for deprecation in the semantic pass:
    result = p.emptyNode
  when defined(nimpretty):
    dec p.em.doIndentMore
    dec p.em.keepIndents

proc optPragmas(p: var Parser): PNode =
  if p.tok.tokType == tkCurlyDotLe and p.validInd:
    parsePragma(p)
  else:
    p.emptyNode

proc parseDoBlock(p: var Parser; info: TLineInfo): PNode =
  #| doBlock = 'do' paramListArrow pragma? colcom stmt
  let params = p.parseParamList(retColon=false)
  let pragmas = optPragmas(p)
  p.colcom(nil)
  if params.kind == nkEmpty and pragmas.kind == nkEmpty:
    parseStmt(p)
  else:
    newProcNode(nkDo, info, body = parseStmt(p),
      params = if params.kind != nkEmpty: params
               else: newTreeI(nkFormalParams, p.lineInfo, p.emptyNode),
      name = p.emptyNode, pattern = p.emptyNode, genericParams = p.emptyNode,
      pragmas = pragmas, exceptions = p.emptyNode)

proc parseProcExpr(p: var Parser; isExpr: bool; kind: TNodeKind): PNode =
  #| routineExpr = ('proc' | 'func' | 'iterator') paramListColon pragma? ('=' COMMENT? stmt)?
  # either a proc type or a anonymous proc
  let info = p.lineInfo
  p.getTok
  let hasSignature = p.tok.tokType in {tkParLe, tkColon} and p.tok.indent < 0
  let params = parseParamList(p)
  let pragmas = optPragmas(p)
  if p.tok.tokType == tkEquals and isExpr:
    p.getTok
    p.skipComment(result)
    result = newProcNode(kind, info, body = parseStmt(p),
      params = params, name = p.emptyNode, pattern = p.emptyNode,
      genericParams = p.emptyNode, pragmas = pragmas, exceptions = p.emptyNode)
  else:
    result = newNodeI(nkProcTy, info)
    if hasSignature:
      result.add params
      if kind == nkFuncDef:
        p.localError ParserReport(kind: rparFuncNotAllowed)
      result.add pragmas

proc isExprStart(p: Parser): bool =
  p.tok.tokType in {tkSymbol, tkAccent, tkOpr, tkNot, tkNil, tkCast, tkIf, tkFor,
     tkProc, tkFunc, tkIterator, tkBind, tkParLe, tkBracketLe, tkCurlyLe,
     tkIntLit..tkCustomLit, tkVar, tkRef, tkPtr,
     tkTuple, tkObject, tkWhen, tkCase, tkOut} + tkBuiltInMagics

proc parseSymbolList(p: var Parser, result: PNode) =
  # progress guaranteed
  while true:
    var s = p.parseSymbol(smAllowNil)
    if s.kind == nkEmpty: break
    result.add s
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(s)

proc parseTypeDescKAux(p: var Parser, kind: TNodeKind,
                       mode: PrimaryMode): PNode =
  result = newNodeP(kind, p)
  p.getTok
  if p.tok.indent != -1 and p.tok.indent <= p.currInd: return
  p.optInd(result)
  if not isOperator(p.tok) and isExprStart(p):
    result.add p.primary(mode)
  if kind == nkDistinctTy and p.tok.tokType == tkSymbol:
    # XXX document this feature!
    let nodeKind =
      if p.tok.ident.s == "with": nkWith
      elif p.tok.ident.s == "without": nkWithout
      else: return
    p.getTok
    let list = newNodeP(nodeKind, p)
    result.add list
    p.parseSymbolList(list)

proc parseVarTuple(p: var Parser): PNode

proc parseFor(p: var Parser): PNode =
  #| forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
  #| forExpr = forStmt
  p.getTokNoInd
  result = newNodeP(nkForStmt, p)
  if p.tok.tokType == tkParLe:
    result.add parseVarTuple(p)
  else:
    var a = identWithPragma(p)
    result.add a
    while p.tok.tokType == tkComma:
      p.getTok
      p.optInd(a)
      if p.tok.tokType == tkParLe:
        result.add parseVarTuple(p)
        break
      a = identWithPragma(p)
      result.add a
  p.eat(tkIn)
  result.add parseExpr(p)
  p.colcom(result)
  result.add parseStmt(p)

template nimprettyDontTouch(body) =
  when defined(nimpretty):
    inc p.em.keepIndents
  body
  when defined(nimpretty):
    dec p.em.keepIndents

proc parseExpr(p: var Parser): PNode =
  #| expr = (blockExpr
  #|       | ifExpr
  #|       | whenExpr
  #|       | caseStmt
  #|       | forExpr
  #|       | tryExpr)
  #|       / simpleExpr
  case p.tok.tokType
  of tkBlock:
    nimprettyDontTouch:
      result = parseBlock(p)
  of tkIf:
    nimprettyDontTouch:
      result = p.parseIfOrWhenExpr(nkIfExpr)
  of tkFor:
    nimprettyDontTouch:
      result = parseFor(p)
  of tkWhen:
    nimprettyDontTouch:
      result = p.parseIfOrWhenExpr(nkWhenExpr)
  of tkCase:
    # Currently we think nimpretty is good enough with case expressions,
    # so it is allowed to touch them:
    #nimprettyDontTouch:
    result = parseCase(p)
  of tkTry:
    nimprettyDontTouch:
      result = p.parseTry(isExpr=true)
  else: result = simpleExpr(p)

proc parseEnum(p: var Parser): PNode
proc parseObject(p: var Parser): PNode
proc parseTypeClass(p: var Parser): PNode

proc primary(p: var Parser, mode: PrimaryMode): PNode =
  #| primary = operatorB primary primarySuffix* |
  #|           tupleDecl | routineExpr | enumDecl
  #|           objectDecl | conceptDecl | ('bind' primary)
  #|           ('var' | 'out' | 'ref' | 'ptr' | 'distinct') primary
  #|         /  prefixOperator* identOrLiteral primarySuffix*
  if isOperator(p.tok):
    # Note 'sigil like' operators are currently not reflected in the grammar
    # and should be removed for Nim 2.0, I don't think anybody uses them.
    let isSigil = isSigilLike(p.tok)
    result = newNodeP(nkPrefix, p)
    var a = newIdentNodeP(p.tok.ident, p)
    result.add a
    p.getTok
    p.optInd(a)
    if isSigil:
      #XXX prefix operators
      let baseInd = p.lex.currLineIndent
      result.add p.primary(pmSkipSuffix)
      result = p.primarySuffix(result, baseInd, mode)
    else:
      result.add p.primary(pmNormal)
    return

  case p.tok.tokType
  of tkTuple: result = p.parseTuple(mode == pmTypeDef)
  of tkProc: result = p.parseProcExpr(mode notin {pmTypeDesc, pmTypeDef}, nkLambda)
  of tkFunc: result = p.parseProcExpr(mode notin {pmTypeDesc, pmTypeDef}, nkFuncDef)
  of tkIterator:
    result = p.parseProcExpr(mode notin {pmTypeDesc, pmTypeDef}, nkLambda)
    if result.kind == nkLambda: result.transitionSonsKind(nkIteratorDef)
    else: result.transitionSonsKind(nkIteratorTy)
  of tkEnum:
    if mode == pmTypeDef:
      prettySection:
        result = parseEnum(p)
    else:
      result = newNodeP(nkEnumTy, p)
      p.getTok
  of tkObject:
    if mode == pmTypeDef:
      prettySection:
        result = parseObject(p)
    else:
      result = newNodeP(nkObjectTy, p)
      p.getTok
  of tkConcept:
    if mode == pmTypeDef:
      result = parseTypeClass(p)
    else:
      p.localError ParserReport(kind: rparConceptNotinType)
  of tkBind:
    result = newNodeP(nkBind, p)
    p.getTok
    p.optInd(result)
    result.add p.primary(pmNormal)
  of tkVar: result = p.parseTypeDescKAux(nkVarTy, mode)
  of tkOut:
    # I like this parser extension to be in 1.4 as it still might turn out
    # useful in the long run.
    result = p.parseTypeDescKAux(nkMutableTy, mode)
  of tkRef: result = p.parseTypeDescKAux(nkRefTy, mode)
  of tkPtr: result = p.parseTypeDescKAux(nkPtrTy, mode)
  of tkDistinct: result = p.parseTypeDescKAux(nkDistinctTy, mode)
  else:
    let baseInd = p.lex.currLineIndent
    result = p.identOrLiteral(mode)
    if mode != pmSkipSuffix:
      result = p.primarySuffix(result, baseInd, mode)

proc binaryNot(p: var Parser; a: PNode): PNode =
  if p.tok.tokType == tkNot:
    let notOpr = newIdentNodeP(p.tok.ident, p)
    p.getTok
    p.optInd(notOpr)
    newTreeI(nkInfix, p.lineInfo, [notOpr, a, parseExpr(p)])
  else:
    a

proc parseTypeDesc(p: var Parser): PNode =
  #| typeDesc = simpleExpr ('not' expr)?
  newlineWasSplitting(p)
  p.binaryNot(p.simpleExpr(pmTypeDesc))

proc parseTypeDefAux(p: var Parser): PNode =
  #| typeDefAux = simpleExpr ('not' expr)?
  p.binaryNot(p.simpleExpr(pmTypeDef))

proc makeCall(n: PNode): PNode =
  ## Creates a call if the given node isn't already a call.
  if n.kind in nkCallKinds:
    n
  else:
    newTreeI(nkCall, n.info, n)

proc postExprBlocks(p: var Parser, x: PNode): PNode =
  #| postExprBlocks = ':' stmt? ( IND{=} doBlock
  #|                            | IND{=} 'of' exprList ':' stmt
  #|                            | IND{=} 'elif' expr ':' stmt
  #|                            | IND{=} 'except' exprList ':' stmt
  #|                            | IND{=} 'finally' ':' stmt
  #|                            | IND{=} 'else' ':' stmt )*
  result = x
  if p.tok.indent >= 0: return

  var
    openingParams = p.emptyNode
    openingPragmas = p.emptyNode

  if p.tok.tokType == tkDo:
    p.getTok
    openingParams = p.parseParamList(retColon=false)
    openingPragmas = optPragmas(p)

  if p.tok.tokType == tkColon:
    result = makeCall(result)
    p.getTok
    p.skipComment(result)
    if p.tok.tokType notin {tkOf, tkElif, tkElse, tkExcept}:
      var stmtList = newTreeI(nkStmtList, p.lineInfo, parseStmt(p))
      # to keep backwards compatibility (see tests/vm/tstringnil)
      if stmtList[0].kind == nkStmtList: stmtList = stmtList[0]

      stmtList.flags.incl nfBlockArg
      result.add if openingParams.kind == nkEmpty and openingPragmas.kind == nkEmpty:
                   stmtList
                 else:
                   newProcNode(nkDo, stmtList.info, body = stmtList,
                     params = if openingParams.kind != nkEmpty: openingParams
                              else: newTreeI(nkFormalParams, p.lineInfo, p.emptyNode),
                     name = p.emptyNode, pattern = p.emptyNode, genericParams = p.emptyNode,
                     pragmas = openingPragmas, exceptions = p.emptyNode)

    while p.sameInd:
      var nextBlock: PNode
      let nextToken = p.tok.tokType
      if nextToken == tkDo:
        let info = p.lineInfo
        p.getTok
        nextBlock = p.parseDoBlock(info)
      else:
        case nextToken
        of tkOf:
          nextBlock = newNodeP(nkOfBranch, p)
          p.exprList(tkColon, nextBlock)
        of tkElif:
          nextBlock = newNodeP(nkElifBranch, p)
          p.getTok
          p.optInd(nextBlock)
          nextBlock.add parseExpr(p)
        of tkExcept:
          nextBlock = newNodeP(nkExceptBranch, p)
          p.exprList(tkColon, nextBlock)
        of tkFinally:
          nextBlock = newNodeP(nkFinally, p)
          p.getTok
        of tkElse:
          nextBlock = newNodeP(nkElse, p)
          p.getTok
        else: break
        p.eat(tkColon)
        nextBlock.add parseStmt(p)

      nextBlock.flags.incl nfBlockArg
      result.add nextBlock

      if nextBlock.kind in {nkElse, nkFinally}: break
  else:
    if openingParams.kind != nkEmpty:
      p.localError ParserReport(
        kind: rparMissingToken, expected: @[":"])

proc parseExprStmt(p: var Parser): PNode =
  #| exprStmt = simpleExpr
  #|          (( '=' optInd expr colonBody? )
  #|          / ( expr ^+ comma
  #|              postExprBlocks
  #|            ))?
  var a = simpleExpr(p)
  if p.tok.tokType == tkEquals:
    result = newNodeP(nkAsgn, p)
    p.getTok
    p.optInd(result)
    result.add a
    result.add p.postExprBlocks(parseExpr(p))
  else:
    # simpleExpr parsed 'p a' from 'p a, b'?
    var isFirstParam = false
    if p.tok.indent < 0 and p.tok.tokType == tkComma and a.kind == nkCommand:
      result = a
      while true:
        p.getTok
        p.optInd(result)
        result.add p.commandParam(isFirstParam, pmNormal)
        if p.tok.tokType != tkComma: break
    elif p.tok.indent < 0 and isExprStart(p):
      result = newTreeI(nkCommand, a.info, a)
      while true:
        result.add p.commandParam(isFirstParam, pmNormal)
        if p.tok.tokType != tkComma: break
        p.getTok
        p.optInd(result)
    else:
      result = a
    result = p.postExprBlocks(result)

proc parseImport(p: var Parser, kind: TNodeKind): PNode =
  #| importStmt = 'import' optInd expr
  #|               ((comma expr)*
  #|               / 'except' optInd (expr ^+ comma))
  #| exportStmt = 'export' optInd expr
  #|               ((comma expr)*
  #|               / 'except' optInd (expr ^+ comma))
  result = newNodeP(kind, p)
  p.getTok                   # skip `import` or `export`
  p.optInd(result)
  result.add parseExpr(p)
  if p.tok.tokType in {tkComma, tkExcept}:
    if p.tok.tokType == tkExcept:
      result.transitionSonsKind(succ(kind))
    p.getTok
    p.optInd(result)
    while true:
      # was: while p.tok.tokType notin {tkEof, tkSad, tkDed}:
      p.hasProgress = false
      let a = parseExpr(p)
      if a.kind == nkEmpty or not p.hasProgress: break
      result.add a
      if p.tok.tokType != tkComma: break
      p.getTok
      p.optInd(a)
  #expectNl(p)

proc parseIncludeStmt(p: var Parser): PNode =
  #| includeStmt = 'include' optInd expr ^+ comma
  result = newNodeP(nkIncludeStmt, p)
  p.getTok                   # skip `import` or `include`
  p.optInd(result)
  while true:
    # was: while p.tok.tokType notin {tkEof, tkSad, tkDed}:
    p.hasProgress = false
    var a = parseExpr(p)
    if a.kind == nkEmpty or not p.hasProgress: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  #expectNl(p)

proc parseFromStmt(p: var Parser): PNode =
  #| fromStmt = 'from' expr 'import' optInd expr (comma expr)*
  result = newNodeP(nkFromStmt, p)
  p.getTok                   # skip `from`
  p.optInd(result)
  result.add parseExpr(p)
  #p.optInd(a)
  p.eat(tkImport)
  p.optInd(result)
  while true:
    # p.tok.tokType notin {tkEof, tkSad, tkDed}:
    p.hasProgress = false
    let a = parseExpr(p)
    if a.kind == nkEmpty or not p.hasProgress: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  #expectNl(p)

proc parseReturnOrRaise(p: var Parser, kind: TNodeKind): PNode =
  #| returnStmt = 'return' optInd expr?
  #| raiseStmt = 'raise' optInd expr?
  #| yieldStmt = 'yield' optInd expr?
  #| discardStmt = 'discard' optInd expr?
  #| breakStmt = 'break' optInd expr?
  #| continueStmt = 'continue' optInd expr?
  result = newNodeP(kind, p)
  p.getTok
  result.add if p.tok.tokType == tkComment:
               p.skipComment(result)
               p.emptyNode
             elif p.tok.indent >= 0 and p.tok.indent <= p.currInd or
                  not isExprStart(p):
               # NL terminates:
               p.emptyNode
               # nimpretty here!
             else:
               p.postExprBlocks(parseExpr(p))

proc parseIfOrWhen(p: var Parser, kind: TNodeKind): PNode =
  #| condStmt = expr colcom stmt COMMENT?
  #|            (IND{=} 'elif' expr colcom stmt)*
  #|            (IND{=} 'else' colcom stmt)?
  #| ifStmt = 'if' condStmt
  #| whenStmt = 'when' condStmt
  result = newNodeP(kind, p)
  while true:
    p.getTok                 # skip `if`, `when`, `elif`
    var branch = newNodeP(nkElifBranch, p)
    p.optInd(branch)
    branch.add parseExpr(p)
    p.colcom(branch)
    branch.add parseStmt(p)
    p.skipComment(branch)
    result.add branch
    if p.tok.tokType != tkElif or not p.sameOrNoInd: break
  if p.tok.tokType == tkElse and p.sameOrNoInd:
    var branch = newNodeP(nkElse, p)
    p.eat(tkElse)
    p.colcom(branch)
    branch.add parseStmt(p)
    result.add branch

proc parseIfOrWhenExpr(p: var Parser, kind: TNodeKind): PNode =
  #| condExpr = expr colcom expr optInd
  #|         ('elif' expr colcom expr optInd)*
  #|          'else' colcom expr
  #| ifExpr = 'if' condExpr
  #| whenExpr = 'when' condExpr
  result = newNodeP(kind, p)
  while true:
    p.getTok                 # skip `if`, `when`, `elif`
    var branch = newNodeP(nkElifExpr, p)
    p.optInd(branch)
    branch.add parseExpr(p)
    p.colcom(branch)
    branch.add parseStmt(p)
    p.skipComment(branch)
    result.add branch
    if p.tok.tokType != tkElif: break
  if p.tok.tokType == tkElse:
    var branch = newNodeP(nkElseExpr, p)
    p.eat(tkElse)
    p.colcom(branch)
    branch.add parseStmt(p)
    result.add branch

proc parseWhile(p: var Parser): PNode =
  #| whileStmt = 'while' expr colcom stmt
  result = newNodeP(nkWhileStmt, p)
  p.getTok
  p.optInd(result)
  result.add parseExpr(p)
  p.colcom(result)
  result.add parseStmt(p)

proc parseCase(p: var Parser): PNode =
  #| ofBranch = 'of' exprList colcom stmt
  #| ofBranches = ofBranch (IND{=} ofBranch)*
  #|                       (IND{=} 'elif' expr colcom stmt)*
  #|                       (IND{=} 'else' colcom stmt)?
  #| caseStmt = 'case' expr ':'? COMMENT?
  #|             (IND{>} ofBranches DED
  #|             | IND{=} ofBranches)
  result = newNodeP(nkCaseStmt, p)
  p.getTok
  result.add parseExpr(p)
  if p.tok.tokType == tkColon: p.getTok
  p.skipComment(result)

  let oldInd = p.currInd
  let wasIndented = p.realInd
  if wasIndented:
    p.currInd = p.tok.indent

  var inElif = false
  while p.sameInd:
    var b: PNode
    case p.tok.tokType
    of tkOf:
      if inElif: break
      b = newNodeP(nkOfBranch, p)
      p.exprList(tkColon, b)
    of tkElif:
      inElif = true
      b = newNodeP(nkElifBranch, p)
      p.getTok
      p.optInd(b)
      b.add parseExpr(p)
    of tkElse:
      b = newNodeP(nkElse, p)
      p.getTok
    else: break
    p.colcom(b)
    b.add parseStmt(p)
    result.add b
    if b.kind == nkElse: break

  if wasIndented:
    p.currInd = oldInd

proc parseTry(p: var Parser; isExpr: bool): PNode =
  #| tryStmt = 'try' colcom stmt &(IND{=}? 'except'|'finally')
  #|            (IND{=}? 'except' exprList colcom stmt)*
  #|            (IND{=}? 'finally' colcom stmt)?
  #| tryExpr = 'try' colcom stmt &(optInd 'except'|'finally')
  #|            (optInd 'except' exprList colcom stmt)*
  #|            (optInd 'finally' colcom stmt)?
  result = newNodeP(nkTryStmt, p)
  p.getTok
  p.colcom(result)
  result.add parseStmt(p)
  var b: PNode = nil
  while p.sameOrNoInd or isExpr:
    case p.tok.tokType
    of tkExcept:
      b = newNodeP(nkExceptBranch, p)
      p.exprList(tkColon, b)
    of tkFinally:
      b = newNodeP(nkFinally, p)
      p.getTok
    else: break
    p.colcom(b)
    b.add parseStmt(p)
    result.add b
  if b == nil:
    p.localError ParserReport(
      kind: rparMissingToken, expected: @["except"])

proc parseExceptBlock(p: var Parser, kind: TNodeKind): PNode =
  result = newNodeP(kind, p)
  p.getTok
  p.colcom(result)
  result.add parseStmt(p)

proc parseBlock(p: var Parser): PNode =
  #| blockStmt = 'block' symbol? colcom stmt
  #| blockExpr = 'block' symbol? colcom stmt
  result = newNodeP(nkBlockStmt, p)
  p.getTokNoInd
  result.add if p.tok.tokType == tkColon: p.emptyNode
             else: parseSymbol(p)
  p.colcom(result)
  result.add parseStmt(p)

proc parseStaticOrDefer(p: var Parser; k: TNodeKind): PNode =
  #| staticStmt = 'static' colcom stmt
  #| deferStmt = 'defer' colcom stmt
  result = newNodeP(k, p)
  p.getTok
  p.colcom(result)
  result.add parseStmt(p)

proc parseAsm(p: var Parser): PNode =
  #| asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
  result = newNodeP(nkAsmStmt, p)
  p.getTokNoInd
  result.add if p.tok.tokType == tkCurlyDotLe: parsePragma(p)
             else: p.emptyNode
  case p.tok.tokType
  of tkStrLit: result.add newStrNodeP(nkStrLit, p.tok.literal, p)
  of tkRStrLit: result.add newStrNodeP(nkRStrLit, p.tok.literal, p)
  of tkTripleStrLit: result.add newStrNodeP(nkTripleStrLit, p.tok.literal, p)
  else:
    p.localError ParserReport(
      kind: rparUnexpectedTokenKind,
      msg: "the 'asm' statement takes a string literal", found: $p.tok)

    result.add p.emptyNode
    return
  p.getTok

proc parseGenericParam(p: var Parser): PNode =
  #| genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
  var a: PNode
  result = newNodeP(nkIdentDefs, p)
  # progress guaranteed
  while true:
    case p.tok.tokType
    of tkIn, tkOut:
      let x = p.lex.cache.getIdent(if p.tok.tokType == tkIn: "in" else: "out")
      a = newNodeP(nkPrefix, p)
      a.add newIdentNodeP(x, p)
      p.getTok
      a.add parseSymbol(p)
    of tkSymbol, tkAccent:
      a = parseSymbol(p)
      if a.kind == nkEmpty: return
    else: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  result.add if p.tok.tokType == tkColon:
               p.getTok
               p.optInd(result)
               parseExpr(p)
             else:
               p.emptyNode
  result.add if p.tok.tokType == tkEquals:
               p.getTok
               p.optInd(result)
               parseExpr(p)
             else:
               p.emptyNode

proc parseGenericParamList(p: var Parser): PNode =
  #| genericParamList = '[' optInd
  #|   genericParam ^* (comma/semicolon) optPar ']'
  result = newNodeP(nkGenericParams, p)
  p.getTok
  p.optInd(result)
  # progress guaranteed
  while p.tok.tokType in {tkSymbol, tkAccent, tkIn, tkOut}:
    var a = parseGenericParam(p)
    result.add a
    if p.tok.tokType notin {tkComma, tkSemiColon}: break
    when defined(nimpretty):
      commaWasSemicolon(p.em)
    p.getTok
    p.skipComment(a)
  p.optPar
  p.eat(tkBracketRi)

proc parsePattern(p: var Parser): PNode =
  #| pattern = '{' stmt '}'
  p.eat(tkCurlyLe)
  result = parseStmt(p)
  p.eat(tkCurlyRi)

proc parseRoutine(p: var Parser, kind: TNodeKind): PNode =
  #| indAndComment = (IND{>} COMMENT)? | COMMENT?
  #| routine = optInd identVis pattern? genericParamList?
  #|   paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
  result = newNodeP(kind, p)
  p.getTok
  p.optInd(result)

  result.add identVis(p)
  result.add if p.validInd and p.tok.tokType == tkCurlyLe:
               p.parsePattern
             else:
               p.emptyNode
  result.add if p.validInd and p.tok.tokType == tkBracketLe:
               p.parseGenericParamList
             else:
               p.emptyNode
  result.add p.parseParamList
  result.add if p.validInd and p.tok.tokType == tkCurlyDotLe:
               p.parsePragma
             else:
               p.emptyNode
  # empty exception tracking:
  result.add p.emptyNode
  let maybeMissEquals = p.tok.tokType != tkEquals
  result.add if p.validInd and not maybeMissEquals:
               p.getTok
               p.skipComment(result)
               parseStmt(p)
             else:
               p.emptyNode
  p.indAndComment(result, maybeMissEquals)
  let body = result[^1]
  if body.kind == nkStmtList and body.len > 0 and
     body[0].kind != nkCommentStmt and body[0].comment.len > 0:
    if result.comment.len == 0:
      # proc fn*(a: int): int = a ## foo
      # => moves comment `foo` to `fn`
      result.comment = body[0].comment
      body[0].comment = ""
    #else:
    #  assert false, p.lex.config$body.info # avoids hard to track bugs, fail early.
    # Yeah, that worked so well. There IS a bug in this logic, now what?

proc newCommentStmt(p: var Parser): PNode =
  #| commentStmt = COMMENT
  result = newNodeP(nkCommentStmt, p)
  result.comment = p.tok.literal
  p.getTok

proc parseSection(p: var Parser, kind: TNodeKind,
                  defparser: proc (p: var Parser): PNode {.nimcall.}): PNode =
  #| section(RULE) = COMMENT? RULE / (IND{>} (RULE / COMMENT)^+IND{=} DED)
  result = newNodeP(kind, p)
  if kind != nkTypeSection: p.getTok
  p.skipComment(result)
  if p.realInd:
    withInd(p):
      p.skipComment(result)
      # progress guaranteed
      while p.sameInd:
        case p.tok.tokType
        of tkSymbol, tkAccent, tkParLe:
          var a = defparser(p)
          p.skipComment(a)
          result.add a
        of tkComment:
          var a = newCommentStmt(p)
          result.add a
        else:
          p.localError ParserReport(kind: rparIdentExpected, found: $p.tok)
          break
    if result.len == 0:
      p.localError ParserReport(kind: rparIdentExpected, found: $p.tok)
  elif p.tok.tokType in {tkSymbol, tkAccent, tkParLe} and p.tok.indent < 0:
    # tkParLe is allowed for ``var (x, y) = ...`` tuple parsing
    result.add defparser(p)
  else:
    p.localError ParserReport(kind: rparIdentExpected, found: $p.tok)

proc parseEnum(p: var Parser): PNode =
  #| enumDecl = 'enum' optInd (symbol pragma? optInd ('=' optInd expr COMMENT?)? comma?)+
  result = newNodeP(nkEnumTy, p)
  p.getTok
  result.add p.emptyNode
  p.optInd(result)
  p.flexComment(result)
  # progress guaranteed
  while true:
    var a = parseSymbol(p)
    if a.kind == nkEmpty: return

    var symPragma = a
    if (p.tok.indent < 0 or p.tok.indent >= p.currInd) and p.tok.tokType == tkCurlyDotLe:
      let pragma = optPragmas(p)
      symPragma = newTreeI(nkPragmaExpr, p.lineInfo, [a, pragma])
    # nimpretty support here
    if p.tok.indent >= 0 and p.tok.indent <= p.currInd:
      result.add symPragma
      break

    if p.tok.tokType == tkEquals and p.tok.indent < 0:
      p.getTok
      p.optInd(symPragma)
      var b = symPragma
      symPragma = newTreeI(nkEnumFieldDef, p.lineInfo, [b, p.parseExpr])
      if p.tok.indent < 0 or p.tok.indent >= p.currInd:
        p.rawSkipComment(symPragma)
    if p.tok.tokType == tkComma and p.tok.indent < 0:
      p.getTok
      p.rawSkipComment(symPragma)
    else:
      if p.tok.indent < 0 or p.tok.indent >= p.currInd:
        p.rawSkipComment(symPragma)
    result.add symPragma
    if p.tok.indent >= 0 and p.tok.indent <= p.currInd or
        p.tok.tokType == tkEof:
      break
  if result.len <= 1:
    p.localError ParserReport(kind: rparIdentExpected, found: $p.tok)

proc parseObjectPart(p: var Parser): PNode
proc parseObjectWhen(p: var Parser): PNode =
  #| objectWhen = 'when' expr colcom objectPart COMMENT?
  #|             ('elif' expr colcom objectPart COMMENT?)*
  #|             ('else' colcom objectPart COMMENT?)?
  result = newNodeP(nkRecWhen, p)
  # progress guaranteed
  while p.sameInd:
    p.getTok                 # skip `when`, `elif`
    var branch = newNodeP(nkElifBranch, p)
    p.optInd(branch)
    branch.add parseExpr(p)
    p.colcom(branch)
    branch.add parseObjectPart(p)
    p.flexComment(branch)
    result.add branch
    if p.tok.tokType != tkElif: break
  if p.tok.tokType == tkElse and p.sameInd:
    var branch = newNodeP(nkElse, p)
    p.eat(tkElse)
    p.colcom(branch)
    branch.add parseObjectPart(p)
    p.flexComment(branch)
    result.add branch

proc parseObjectCase(p: var Parser): PNode =
  #| objectBranch = 'of' exprList colcom objectPart
  #| objectBranches = objectBranch (IND{=} objectBranch)*
  #|                       (IND{=} 'elif' expr colcom objectPart)*
  #|                       (IND{=} 'else' colcom objectPart)?
  #| objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
  #|             (IND{>} objectBranches DED
  #|             | IND{=} objectBranches)
  result = newNodeP(nkRecCase, p)
  p.getTokNoInd
  var a = newNodeP(nkIdentDefs, p)
  a.add identWithPragma(p)
  p.eat(tkColon)
  a.add parseTypeDesc(p)
  a.add p.emptyNode
  result.add a
  if p.tok.tokType == tkColon: p.getTok
  p.flexComment(result)
  let
    oldInd = p.currInd
    wasIndented = p.realInd
  if wasIndented:
    p.currInd = p.tok.indent
  # progress guaranteed
  while p.sameInd:
    var b: PNode
    case p.tok.tokType
    of tkOf:
      b = newNodeP(nkOfBranch, p)
      p.exprList(tkColon, b)
    of tkElse:
      b = newNodeP(nkElse, p)
      p.getTok
    else: break
    p.colcom(b)
    var fields = parseObjectPart(p)
    if fields.kind == nkEmpty:
      p.localError ParserReport(kind: rparIdentExpected)
      fields = newNodeP(nkNilLit, p) # don't break further semantic checking
    b.add fields
    result.add b
    if b.kind == nkElse: break
  if wasIndented:
    p.currInd = oldInd

proc parseObjectPart(p: var Parser): PNode =
  #| objectPart = IND{>} objectPart^+IND{=} DED
  #|            / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
  if p.realInd:
    result = newNodeP(nkRecList, p)
    withInd(p):
      p.rawSkipComment(result)
      while p.sameInd:
        case p.tok.tokType
        of tkCase, tkWhen, tkSymbol, tkAccent, tkNil, tkDiscard:
          result.add parseObjectPart(p)
        else:
          p.localError ParserReport(kind: rparIdentExpected, found: $p.tok)
          break
  elif p.sameOrNoInd:
    case p.tok.tokType
    of tkWhen:
      result = parseObjectWhen(p)
    of tkCase:
      result = parseObjectCase(p)
    of tkSymbol, tkAccent:
      result = p.parseIdentColonEquals({withPragma})
      if p.tok.indent < 0 or p.tok.indent >= p.currInd:
        p.rawSkipComment(result)
    of tkNil, tkDiscard:
      result = newNodeP(nkNilLit, p)
      p.getTok
    else:
      result = p.emptyNode
  else:
    result = p.emptyNode

proc parseObject(p: var Parser): PNode =
  #| objectDecl = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
  result = newNodeP(nkObjectTy, p)
  p.getTok
  result.add if p.tok.tokType == tkCurlyDotLe and p.validInd:
               # Deprecated since v0.20.0
               p.localError ParserReport(kind: rparPragmaNotFollowingTypeName)
               p.parsePragma
             else:
               p.emptyNode
  result.add if p.tok.tokType == tkOf and p.tok.indent < 0:
               var a = newNodeP(nkOfInherit, p)
               p.getTok
               a.add parseTypeDesc(p)
               a
             else:
               p.emptyNode
  if p.tok.tokType == tkComment:
    p.skipComment(result)
  # an initial IND{>} HAS to follow:
  result.add if p.realInd:
               parseObjectPart(p)
             else:
               p.emptyNode

proc parseTypeClassParam(p: var Parser): PNode =
  let modifier =
    case p.tok.tokType
    of tkOut, tkVar: nkVarTy
    of tkPtr: nkPtrTy
    of tkRef: nkRefTy
    of tkStatic: nkStaticTy
    of tkType: nkTypeOfExpr
    else: nkEmpty

  if modifier != nkEmpty:
    result = newNodeP(modifier, p)
    p.getTok
    result.add p.parseSymbol
  else:
    result = p.parseSymbol

proc parseTypeClass(p: var Parser): PNode =
  #| conceptParam = ('var' | 'out')? symbol
  #| conceptDecl = 'concept' conceptParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
  #|               &IND{>} stmt
  result = newNodeP(nkTypeClassTy, p)
  p.getTok
  if p.tok.tokType == tkComment:
    p.skipComment(result)

  if p.tok.indent < 0:
    var args = newNodeP(nkArgList, p)
    result.add args
    args.add p.parseTypeClassParam
    while p.tok.tokType == tkComma:
      p.getTok
      args.add p.parseTypeClassParam
  else:
    result.add p.emptyNode # see ast.isNewStyleConcept
  result.add if p.tok.tokType == tkCurlyDotLe and p.validInd:
               parsePragma(p)
             else:
               p.emptyNode
  result.add if p.tok.tokType == tkOf and p.tok.indent < 0:
               var a = newNodeP(nkOfInherit, p)
               p.getTok
               # progress guaranteed
               while true:
                 a.add parseTypeDesc(p)
                 if p.tok.tokType != tkComma: break
                 p.getTok
               a
             else:
               p.emptyNode
  if p.tok.tokType == tkComment:
    p.skipComment(result)
  # an initial IND{>} HAS to follow:
  result.add if p.realInd:
               parseStmt(p)
             else:
               if result.isNewStyleConcept:
                 p.localError ParserReport(
                   kind: rparRotineExpected,
                   msg:
"routine expected, but found '$1' (empty new-styled concepts are not allowed)" % [$p.tok],
                   found: $p.tok
                 )
               p.emptyNode

proc parseTypeDef(p: var Parser): PNode =
  #|
  #| typeDef = identWithPragmaDot genericParamList? '=' optInd typeDefAux
  #|             indAndComment? / identVisDot genericParamList? pragma '=' optInd typeDefAux
  #|             indAndComment?
  result = newNodeP(nkTypeDef, p)
  let identifier = p.identVis(allowDot=true)
  var identPragma = identifier
  var foundPragmas = false

  if p.tok.tokType == tkCurlyDotLe:
    let pragma = optPragmas(p)
    identPragma = newTreeI(nkPragmaExpr, p.lineInfo, [identifier, pragma])
    foundPragmas = true

  let genericParam = if p.validInd and p.tok.tokType == tkBracketLe:
                   if foundPragmas:
                     # Deprecated since v0.20.0
                     p.localError ParserReport(kind: rparPragmaBeforeGenericParameters)
                   parseGenericParamList(p)
                 else:
                   p.emptyNode

  if not foundPragmas:
    let pragma = optPragmas(p)
    if pragma.kind != nkEmpty:
      identPragma = newTreeI(nkPragmaExpr, p.lineInfo, [identifier, pragma])
  elif p.tok.tokType == tkCurlyDotLe:
    p.localError ParserReport(kind: rparPragmaAlreadyPresent)

  result.add identPragma
  result.add genericParam

  result.add if p.tok.tokType == tkEquals:
               result.info = p.lineInfo
               p.getTok
               p.optInd(result)
               parseTypeDefAux(p)
             else:
               p.emptyNode
  p.indAndComment(result)    # special extension!

proc parseVarTuple(p: var Parser): PNode =
  #| varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
  result = newNodeP(nkVarTuple, p)
  p.getTok                   # skip '('
  p.optInd(result)
  # progress guaranteed
  while p.tok.tokType in {tkSymbol, tkAccent}:
    var a = p.identWithPragma(allowDot=true)
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.skipComment(a)
  result.add p.emptyNode         # no type desc
  p.optPar
  p.eat(tkParRi)

proc parseVariable(p: var Parser): PNode =
  #| colonBody = colcom stmt postExprBlocks?
  #| variable = (varTuple / identColonEquals) colonBody? indAndComment
  if p.tok.tokType == tkParLe:
    result = parseVarTuple(p)
    p.eat(tkEquals)
    p.optInd(result)
    result.add parseExpr(p)
  else:
    result = p.parseIdentColonEquals({withPragma, withDot})
  result[^1] = p.postExprBlocks(result[^1])
  p.indAndComment(result)

proc parseConstant(p: var Parser): PNode =
  #| constant = (varTuple / identWithPragma) (colon typeDesc)? '=' optInd expr indAndComment
  if p.tok.tokType == tkParLe: result = parseVarTuple(p)
  else:
    result = newNodeP(nkConstDef, p)
    result.add identWithPragma(p)
    if p.tok.tokType == tkColon:
      p.getTok
      p.optInd(result)
      result.add parseTypeDesc(p)
    else:
      result.add p.emptyNode
  p.eat(tkEquals)
  p.optInd(result)
  #add(result, parseStmtListExpr(p))
  result.add parseExpr(p)
  result[^1] = p.postExprBlocks(result[^1])
  p.indAndComment(result)

proc parseBind(p: var Parser, k: TNodeKind): PNode =
  #| bindStmt = 'bind' optInd qualifiedIdent ^+ comma
  #| mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
  result = newNodeP(k, p)
  p.getTok
  p.optInd(result)
  # progress guaranteed
  while true:
    var a = qualifiedIdent(p)
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  #expectNl(p)

proc parseStmtPragma(p: var Parser): PNode =
  #| pragmaStmt = pragma (':' COMMENT? stmt)?
  result = parsePragma(p)
  if p.tok.tokType == tkColon and p.tok.indent < 0:
    let a = result
    result = newNodeI(nkPragmaBlock, a.info)
    p.getTok
    p.skipComment(result)
    result.add a
    result.add parseStmt(p)

proc simpleStmt(p: var Parser): PNode =
  #| simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
  #|            | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
  #|            | includeStmt | commentStmt) / exprStmt) COMMENT?
  #|
  result = case p.tok.tokType
           of tkReturn: p.parseReturnOrRaise(nkReturnStmt)
           of tkRaise: p.parseReturnOrRaise(nkRaiseStmt)
           of tkYield: p.parseReturnOrRaise(nkYieldStmt)
           of tkDiscard: p.parseReturnOrRaise(nkDiscardStmt)
           of tkBreak: p.parseReturnOrRaise(nkBreakStmt)
           of tkContinue: p.parseReturnOrRaise(nkContinueStmt)
           of tkCurlyDotLe: parseStmtPragma(p)
           of tkImport: p.parseImport(nkImportStmt)
           of tkExport: p.parseImport(nkExportStmt)
           of tkFrom: parseFromStmt(p)
           of tkInclude: parseIncludeStmt(p)
           of tkComment: newCommentStmt(p)
           elif isExprStart(p): parseExprStmt(p)
           else: p.emptyNode
  if result.kind notin {nkEmpty, nkCommentStmt}: p.skipComment(result)

proc complexOrSimpleStmt(p: var Parser): PNode =
  #| complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
  #|                     | tryStmt | forStmt
  #|                     | blockStmt | staticStmt | deferStmt | asmStmt
  #|                     | 'proc' routine
  #|                     | 'method' routine
  #|                     | 'func' routine
  #|                     | 'iterator' routine
  #|                     | 'macro' routine
  #|                     | 'template' routine
  #|                     | 'converter' routine
  #|                     | 'type' section(typeDef)
  #|                     | 'const' section(constant)
  #|                     | ('let' | 'var' | 'using') section(variable)
  #|                     | bindStmt | mixinStmt)
  #|                     / simpleStmt
  case p.tok.tokType
  of tkIf: result = p.parseIfOrWhen(nkIfStmt)
  of tkWhile: result = parseWhile(p)
  of tkCase: result = parseCase(p)
  of tkTry: result = p.parseTry(isExpr=false)
  of tkFinally: result = p.parseExceptBlock(nkFinally)
  of tkExcept: result = p.parseExceptBlock(nkExceptBranch)
  of tkFor: result = parseFor(p)
  of tkBlock: result = parseBlock(p)
  of tkStatic: result = p.parseStaticOrDefer(nkStaticStmt)
  of tkDefer: result = p.parseStaticOrDefer(nkDefer)
  of tkAsm: result = parseAsm(p)
  of tkProc: result = p.parseRoutine(nkProcDef)
  of tkFunc: result = p.parseRoutine(nkFuncDef)
  of tkMethod: result = p.parseRoutine(nkMethodDef)
  of tkIterator: result = p.parseRoutine(nkIteratorDef)
  of tkMacro: result = p.parseRoutine(nkMacroDef)
  of tkTemplate: result = p.parseRoutine(nkTemplateDef)
  of tkConverter: result = p.parseRoutine(nkConverterDef)
  of tkType:
    p.getTok
    if p.tok.tokType == tkParLe:
      p.getTok
      result = newNodeP(nkTypeOfExpr, p)
      result.add p.primary(pmTypeDesc)
      p.eat(tkParRi)
      result = p.parseOperators(result, -1, pmNormal)
    else:
      result = p.parseSection(nkTypeSection, parseTypeDef)
  of tkConst:
    prettySection:
      result = p.parseSection(nkConstSection, parseConstant)
  of tkLet:
    prettySection:
      result = p.parseSection(nkLetSection, parseVariable)
  of tkVar:
    prettySection:
      result = p.parseSection(nkVarSection, parseVariable)
  of tkWhen: result = p.parseIfOrWhen(nkWhenStmt)
  of tkBind: result = p.parseBind(nkBindStmt)
  of tkMixin: result = p.parseBind(nkMixinStmt)
  of tkUsing: result = p.parseSection(nkUsingStmt, parseVariable)
  else: result = simpleStmt(p)

proc parseStmt(p: var Parser): PNode =
  #| stmt = (IND{>} complexOrSimpleStmt^+(IND{=} / ';') DED)
  #|      / simpleStmt ^+ ';'
  if p.realInd:
    # nimpretty support here
    result = newNodeP(nkStmtList, p)
    withInd(p):
      while true:
        if p.sameInd:
          discard
        elif p.tok.tokType == tkSemiColon:
          p.getTok
          if p.sameOrNoInd: discard
          else: break
        else:
          if p.realInd and p.tok.tokType != tkDot:
            p.localError ParserReport(kind: rparInvalidIndentation)
          break
        if p.tok.tokType in {tkCurlyRi, tkParRi, tkCurlyDotRi, tkBracketRi}:
          # XXX this ensures tnamedparamanonproc still compiles;
          # deprecate this syntax later
          break
        p.hasProgress = false
        if p.tok.tokType in {tkElse, tkElif}:
          break # Allow this too, see tests/parser/tifexprs

        let a = complexOrSimpleStmt(p)
        if a.kind == nkEmpty and not p.hasProgress:
          p.localError ParserReport(kind: rparExprExpected)
          break
        else:
          result.add a

        if not p.hasProgress and p.tok.tokType == tkEof: break
  else:
    # the case statement is only needed for better error messages:
    case p.tok.tokType
    of tkIf, tkWhile, tkCase, tkTry, tkFor, tkBlock, tkAsm, tkProc, tkFunc,
       tkIterator, tkMacro, tkType, tkConst, tkWhen, tkVar:
      p.localError ParserReport(kind: rparNestableRequiresIndentation)
      result = p.emptyNode
    else:
      if p.inSemiStmtList > 0:
        result = simpleStmt(p)
        if result.kind == nkEmpty:
          p.localError ParserReport(kind: rparExprExpected, found: $p.tok)
      else:
        result = newNodeP(nkStmtList, p)
        while true:
          if p.tok.indent >= 0:
            p.localError ParserReport(kind: rparInvalidIndentation)
          p.hasProgress = false
          let a = simpleStmt(p)
          let err = not p.hasProgress
          if a.kind == nkEmpty:
            p.localError ParserReport(kind: rparExprExpected, found: $p.tok)
          result.add a
          if p.tok.tokType != tkSemiColon: break
          p.getTok
          if err and p.tok.tokType == tkEof: break

proc parseAll(p: var Parser): PNode =
  ## Parses the rest of the input stream held by the parser into a PNode.
  result = newNodeP(nkStmtList, p)
  while p.tok.tokType != tkEof:
    p.hasProgress = false
    var a = complexOrSimpleStmt(p)
    if a.kind != nkEmpty and p.hasProgress:
      result.add a
    else:
      p.localError ParserReport(kind: rparExprExpected, found: $p.tok)
      # bugfix: consume a token here to prevent an endless loop:
      p.getTok
    if p.tok.indent != 0:
      p.localError ParserReport(kind: rparInvalidIndentation)

proc parseTopLevelStmt(p: var Parser): PNode =
  ## Implements an iterator which, when called repeatedly, returns the next
  ## top-level statement or emptyNode if end of stream.
  result = p.emptyNode
  # progress guaranteed
  while true:
    # nimpretty support here
    if p.tok.indent != 0:
      if p.firstTok and p.tok.indent < 0: discard
      elif p.tok.tokType != tkSemiColon:
        # special casing for better error messages:
        if p.tok.tokType == tkOpr and p.tok.ident.s == "*":
          p.localError ParserReport(kind: rparMisplacedExport,
            msg: "invalid indentation; an export marker '*' follows the declared identifier")
        else:
          p.localError ParserReport(kind: rparInvalidIndentation)
    p.firstTok = false
    case p.tok.tokType
    of tkSemiColon:
      p.getTok
      if p.tok.indent <= 0:
        discard
      else:
        p.localError ParserReport(kind: rparInvalidIndentation)
      p.firstTok = true
    of tkEof: break
    else:
      result = complexOrSimpleStmt(p)
      if result.kind == nkEmpty:
        p.localError ParserReport(kind: rparExprExpected, found: $p.tok)
      break

proc parseString*(s: string; cache: IdentCache; config: ConfigRef;
                  filename: string = ""; line: int = 0): PNode =
  ## Parses a string into an AST, returning the top node.
  ## `filename` and `line`, although optional, provide info so that the
  ## compiler can generate correct error messages referring to the original
  ## source.
  var stream = llStreamOpen(s)
  stream.lineOffset = line

  var parser: Parser
  openParser(parser, AbsoluteFile filename, stream, cache, config)

  result = parser.parseAll
  closeParser(parser)
