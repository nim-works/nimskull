#
#
#           The Nim Compiler
#        (c) Copyright 2015 Andreas Rumpf
#
#    See the file "copying.txt", included in this
#    distribution, for details about the copyright.
#

## This module implements the parser of the standard Nimskull syntax.
## The parser strictly reflects the grammar ("doc/grammar.txt"); however
## it uses several helper routines to keep the parser small. A special
## efficient algorithm is used for the precedence levels. The parser here can
## be seen as a refinement of the grammar, as it specifies how the AST is built
## from the grammar and how comments belong to the AST.


# In fact the grammar is generated from this file:
when isMainModule:
  # Leave a note in grammar.txt that it is generated:
  #| # This file is generated by compiler/parser.nim.
  import std/pegs
  var outp = open("doc/grammar.txt", fmWrite)
  for line in lines("compiler/parser.nim"):
    if line =~ peg" \s* '#| ' {.*}":
      outp.write matches[0], "\L"
  outp.close

  import "../.." / tools / grammar_nanny
  checkGrammarFile()

import
  compiler/ast/[
    llstream,
    lexer,
    idents,
    ast_parsed_types,
    lineinfos
  ],
  std/[
    strutils,
  ],
  compiler/front/[
    msgs,
    options,
  ],
  compiler/utils/[
    pathutils,
    astrepr,
    idioms,
  ]

type
  ParserError* = object of CatchableError
    instLoc*: InstantiationInfo

  ParseDiags = seq[ParseDiag]

  Parser* = object            ## A Parser object represents a file that
                              ## is being parsed
    currInd: int              ## current indentation level
    firstTok: bool            ## Has the first token been read?
    hasProgress: bool         ## some while loop requires progress ensurance
    lex*: Lexer               ## The lexer that is used for parsing
    tok*: Token               ## The current token
    lineStartPrevious*: int
    lineNumberPrevious*: int
    bufposPrevious*: int
    inPragma*: int            ## Pragma level
    inSemiStmtList*: int
    emptyNode: ParsedNode
    diags*: ParseDiags

  SymbolMode = enum
    smNormal, smAllowNil, smAfterDot

  PrimaryMode = enum
    pmNormal, pmTypeDesc, pmTypeDef, pmSkipSuffix

# single entry point API:
proc parseString*(s: string; cache: IdentCache; config: ConfigRef;
                  filename: string = ""; line: int = 0): ParsedNode

# core API, the inteded usage is:
# 1. open the parser
# 2. parse one top level statement at a time and/or parse all/remaining tokens
# 3. close the parser
proc openParser*(p: var Parser, fileIdx: FileIndex, inputStream: PLLStream,
                 cache: IdentCache; config: ConfigRef)
proc openParser*(p: var Parser, filename: AbsoluteFile, inputStream: PLLStream,
                 cache: IdentCache; config: ConfigRef)
proc parseTopLevelStmt*(p: var Parser): ParsedNode
proc parseAll*(p: var Parser): ParsedNode
proc closeParser*(p: var Parser)

# originally intended as helpers for the other parsers, they're not used
# anywhere, and are kept here temporarily as reference and to support mutually
# recursive calls

proc getTok(p: var Parser)
proc eat(p: var Parser, tokType: TokType)

proc parseTry(p: var Parser; isExpr: bool): ParsedNode
proc parseCase(p: var Parser): ParsedNode
proc parseStmtPragma(p: var Parser): ParsedNode
proc parsePragma(p: var Parser): ParsedNode
proc postExprBlocks(p: var Parser, x: ParsedNode): ParsedNode
proc parseExprStmt(p: var Parser): ParsedNode
proc parseBlock(p: var Parser): ParsedNode
proc parseSymbol(p: var Parser, mode = smNormal): ParsedNode
proc primary(p: var Parser, mode: PrimaryMode): ParsedNode
proc simpleExprAux(p: var Parser, limit: int, mode: PrimaryMode): ParsedNode

proc skipInd(p: var Parser)
proc optInd(p: var Parser, n: ParsedNode)
proc indAndComment(p: var Parser, n: ParsedNode, maybeMissEquals = false)
proc skipComment(p: var Parser, node: ParsedNode)
proc optPar(p: var Parser)

proc isOperator(tok: Token): bool
proc lineInfo(p: Parser): TLineInfo

# implementation

proc getTok(p: var Parser) =
  ## Get the next token from the parser's lexer, and store it in the parser's
  ## `tok` member.
  p.lineNumberPrevious = p.lex.lineNumber
  p.lineStartPrevious = p.lex.lineStart
  p.bufposPrevious = p.lex.bufpos

  let lexDiagOffset = p.lex.diagOffset # capture before using the lexer

  p.lex.rawGetTok(p.tok)

  if p.tok.tokType == tkError:
    p.lex.config.handleLexerDiag(p.tok.error, instLoc(-1), doAbort)

  for d in p.lex.errorsHintsAndWarnings(lexDiagOffset):
    p.lex.config.handleLexerDiag(d, instLoc(-1))

  p.hasProgress = true

proc newEmptyParsedNode(p: Parser): ParsedNode {.inline.} =
  let info = p.lineInfo
  newEmptyParsedNode(p.lex.fileIdx, info.line, info.col)

proc openParser*(p: var Parser, fileIdx: FileIndex, inputStream: PLLStream,
                 cache: IdentCache; config: ConfigRef) =
  ## Open a parser, using the given arguments to set up its internal state.
  initToken(p.tok)
  openLexer(p.lex, fileIdx, inputStream, cache, config)
  p.getTok                   # read the first token
  p.firstTok = true
  p.emptyNode = newEmptyParsedNode(p.lex.fileIdx)
  p.diags.setLen(0) # clear diags in case the parser is reopened

proc openParser*(p: var Parser, filename: AbsoluteFile, inputStream: PLLStream,
                 cache: IdentCache; config: ConfigRef) =
  openParser(p, fileInfoIdx(config, filename), inputStream, cache, config)

proc closeParser(p: var Parser) =
  ## Close a parser, freeing up its resources.
  closeLexer(p.lex)

proc finalizeDiag(p: var Parser, diag: ParseDiag) =
  ## add the `diag` to the `p`arser and if required raise an a `ParserError`,
  ## as the name indicates, call this after the diag has all data its set.
  p.diags.add diag

  p.lex.config.handleParserDiag(diag, instLoc(-1))

template invalidIndentationWithForgotEqualSignHint(
    p: var Parser,
    eqInfo: TLineInfo,
    loc = instLoc(-1)) =
  ## record an invalid indentation diagnostic, including a hint for a possibly
  ## missing equal sign (`=`).
  p.finalizeDiag:
    ParseDiag(location: p.lineInfo,
              instLoc: loc,
              kind: pdkInvalidIndentationWithForgotEqualSignHint,
              eqLineInfo: eqInfo)

template invalidExpectedIdent(p: var Parser, loc = instLoc(-1)) =
  p.finalizeDiag:
    ParseDiag(location: p.lineInfo,
              instLoc: loc,
              kind: pdkIdentExpected,
              found: p.tok)

template invalidExpectedExpr(p: var Parser, loc = instLoc(-1)) =
  p.finalizeDiag:
    ParseDiag(location: p.lineInfo,
              instLoc: loc,
              kind: pdkExprExpected,
              found: p.tok)

template invalidExpectedTokenMissing(
    p: var Parser,
    t1: TokType, t2 = tkInvalid,
    loc = instLoc(-1)) =
  p.finalizeDiag:
    ParseDiag(location: p.lineInfo,
              instLoc: loc,
              kind: pdkMissingToken,
              missedToks: if t2 == tkInvalid: @[t1] else: @[t1, t2])

proc currTokenDiag(p: var Parser, kind: ParseDiagKind, loc = instLoc(-1)) =
  assert kind in pdkWithoutExtraData
  p.finalizeDiag:
    ParseDiag(location: p.lineInfo,
              instLoc: loc,
              kind: kind)

template invalidIndentation(p: var Parser, loc = instLoc(-1)) =
  ## record an invalid indentation diagnostic
  p.currTokenDiag(pdkInvalidIndentation, loc)

template withInd(p, body: untyped) =
  let oldInd = p.currInd
  p.currInd = p.tok.indent
  body
  p.currInd = oldInd

template realInd(p): bool = p.tok.indent > p.currInd
template sameInd(p): bool = p.tok.indent == p.currInd
template sameOrNoInd(p): bool = p.tok.indent == p.currInd or p.tok.indent < 0

proc validInd(p: var Parser): bool {.inline.} =
  p.tok.indent < 0 or p.tok.indent > p.currInd

proc rawSkipComment(p: var Parser, node: ParsedNode) =
  if p.tok.tokType == tkComment:
    if node != nil:
      var rhs = node.comment
      rhs.add p.tok.literal
      node.comment = move rhs
    else:
      # xxx: consider reworking this as an internal error/raise
      p.lex.config.internalError("skipComment")
    p.getTok

proc skipComment(p: var Parser, node: ParsedNode) =
  if p.tok.indent < 0: p.rawSkipComment(node)

proc flexComment(p: var Parser, node: ParsedNode) =
  if p.tok.indent < 0 or p.realInd: p.rawSkipComment(node)

proc skipInd(p: var Parser) =
  if p.tok.indent >= 0:
    if not p.realInd:
      p.invalidIndentation()

proc optPar(p: var Parser) =
  if p.tok.indent >= 0:
    if p.tok.indent < p.currInd:
      p.invalidIndentation()

proc optInd(p: var Parser, n: ParsedNode) =
  p.skipComment(n)
  p.skipInd

proc getTokNoInd(p: var Parser) =
  p.getTok
  if p.tok.indent >= 0:
    p.invalidIndentation()

proc eat(p: var Parser, tokType: TokType) =
  ## Move the parser to the next token if the current token is of type
  ## `tokType`, otherwise error.
  if p.tok.tokType == tokType:
    p.getTok
  else:
    p.finalizeDiag:
      ParseDiag(location: p.lineInfo,
                instLoc: instLoc(-1),
                kind: pdkUnexpectedToken,
                expected: tokType,
                actual: p.tok)

proc lineInfo(p: Parser): TLineInfo =
  ## Retrieve the line information associated with the parser's current state.
  getLineInfo(p.lex, p.tok)

proc indAndComment(p: var Parser, n: ParsedNode, maybeMissEquals = false) =
  if p.realInd:
    if p.tok.tokType == tkComment:
      p.rawSkipComment(n)
    elif maybeMissEquals:
      let
        prevLine = p.lineNumberPrevious
        prevCol = p.bufposPrevious - p.lineStartPrevious
      p.invalidIndentationWithForgotEqualSignHint:
        newLineInfo(p.lex.fileIdx, prevLine, prevCol)
    else:
      p.invalidIndentation()
  else:
    p.skipComment(n)

proc newLitNode(p: Parser, kind: ParsedKindLiteral, lit: Token): ParsedNode =
  ## Create a leaf literal node
  newParsedLitNode(kind, p.lex.fileIdx, lit.toParsedToken())

template toParsedToken(t: ParsedToken): ParsedToken =
  ## useful identity routine
  t

proc newNode(
    p: Parser,
    kind: ParsedKindWithSons,
    token: Token | ParsedToken,
    subnodes: sink seq[ParsedNode] = @[],
  ): ParsedNode =
  ## Create a new non-leaf parsed node using line information from the
  ## parser p
  newParsedNode(kind, p.lex.fileIdx, toParsedToken(token), subnodes)

proc newNodeConsumingTok(
    p: var Parser,
    kind: ParsedKindWithSons,
    subnodes: sink seq[ParsedNode] = @[]): ParsedNode =
  ## Create a new non-leaf parsed node from the current token and advance the
  ## parser
  result = newNode(p, kind, p.tok, subnodes)
  p.getTok

proc newBracketNode(
    p: Parser,
    kind: ParsedKindBracket,
    openToken: Token,
    subnodes: sink seq[ParsedNode] = @[],
  ): ParsedNode =
  ## Create a new non-leaf bracket parsed node using file information from the
  ## parser p
  newParsedNode(kind, p.lex.fileIdx, toParsedToken(openToken), subnodes)

proc newIdentNode(p: Parser, token: Token): ParsedNode =
  ## Create a new ident leaf parsed node using line information from the
  ## parser and provided identifier as a token.
  # HACK this is a temporary transition function until ParsedNode can fully
  # switch over to using token indices
  #
  # NOTE this handling loses information about original token indentation
  # and positioning
  newParsedNodeIdent(p.lex.fileIdx, toParsedToken(token))

proc newNilLitNode(p: Parser, token: Token): ParsedNode =
  ## Create a new nil literal node
  ParsedNode(kind: pnkNilLit,
             fileIndex: p.lex.fileIdx,
             lit: toParsedToken(token))

proc newAccQuotedNode(p: Parser, token: Token): ParsedNode =
  ## Creates a new accent quoted node, who's children need to be populated
  ParsedNode(
    kind: pnkAccQuoted,
    fileIndex: p.lex.fileIdx,
    quote: toParsedToken(token),
    idents: @[])

proc parseExpr(p: var Parser): ParsedNode
proc parseStmt(p: var Parser): ParsedNode
proc parseTypeDesc(p: var Parser): ParsedNode
proc parseParamList(p: var Parser, retColon = true): ParsedNode

proc isSigilLike(tok: Token): bool {.inline.} =
  tok.tokType == tkOpr and tok.ident.s[0] == '@'

proc isRightAssociative(tok: Token): bool {.inline.} =
  ## Determines whether the token is right assocative.
  tok.tokType == tkOpr and tok.ident.s[0] == '^'
  # or (tok.ident.s.len > 1 and tok.ident.s[^1] == '>')

proc isUnary(tok: Token): bool =
  ## Check if the given token is a unary operator
  tok.tokType in {tkOpr, tkDotDot} and
  tok.strongSpaceB == 0 and tok.strongSpaceA > 0

proc checkBinary(p: var Parser) {.inline.} =
  ## Check if the current parser token is a binary operator.
  # we don't check '..' here as that's too annoying
  if p.tok.tokType == tkOpr and
     p.tok.strongSpaceB > 0 and p.tok.strongSpaceA == 0:
    p.finalizeDiag:
      ParseDiag(location: p.lineInfo,
                instLoc: instLoc(-1),
                kind: pdkInconsistentSpacing,
                found: p.tok)

#| module = stmt ^* (';' / IND{=})
#|
#| comma = ',' COMMENT?
#| semicolon = ';' COMMENT?
#| colon = ':' COMMENT?
#| colcom = ':' COMMENT?
#|
#| operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
#|          | 'or' | 'xor' | 'and'
#|          | 'is' | 'isnot' | 'in' | 'notin' | 'of' | 'as' | 'from'
#|          | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
#|
#| prefixOperator = operator
#|
#| optInd = COMMENT? IND?
#| optPar = (IND{>} | IND{=})?
#|
#| simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
#| arrowExpr = assignExpr (OP1 optInd assignExpr)*
#| assignExpr = orExpr (OP2 optInd orExpr)*
#| orExpr = andExpr (OP3 optInd andExpr)*
#| andExpr = cmpExpr (OP4 optInd cmpExpr)*
#| cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
#| sliceExpr = ampExpr (OP6 optInd ampExpr)*
#| ampExpr = plusExpr (OP7 optInd plusExpr)*
#| plusExpr = mulExpr (OP8 optInd mulExpr)*
#| mulExpr = dollarExpr (OP9 optInd dollarExpr)*
#| dollarExpr = primary (OP10 optInd primary)*

proc isOperator(tok: Token): bool =
  #| operatorB = OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 |
  #|             'div' | 'mod' | 'shl' | 'shr' | 'in' | 'notin' |
  #|             'is' | 'isnot' | 'not' | 'of' | 'as' | 'from' | '..' | 'and' | 'or' | 'xor'
  tok.tokType in {tkOpr, tkDiv, tkMod, tkShl, tkShr, tkIn, tkNotin, tkIs,
                  tkIsnot, tkNot, tkOf, tkAs, tkFrom, tkDotDot, tkAnd,
                  tkOr, tkXor}

proc colcom(p: var Parser, n: ParsedNode) =
  p.eat(tkColon)
  p.skipComment(n)

const tkBuiltInMagics = {tkType, tkStatic, tkAddr}

proc parseSymbol(p: var Parser, mode = smNormal): ParsedNode =
  #| symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
  #|        | IDENT | KEYW
  case p.tok.tokType
  of tkSymbol:
    result = p.newIdentNode(p.tok)
    p.getTok
  of tkKeywords:
    if p.tok.tokType in tkBuiltInMagics or mode == smAfterDot:
      # for backwards compatibility these 2 are always valid:
      result = p.newIdentNode(p.tok)
      p.getTok
    elif p.tok.tokType == tkNil and mode == smAllowNil:
      result = p.newNilLitNode(p.tok)
      p.getTok
    else:
      p.invalidExpectedIdent()
      # error correction: consume the token and treat it as an identifier in
      # order to allow for further progress
      result = p.newIdentNode(p.tok)
      p.getTok
  of tkAccent:
    result = p.newAccQuotedNode(p.tok)
    p.getTok
    while true:
      case p.tok.tokType
      of tkAccent:
        if result.idents.len == 0:
          p.currTokenDiag(pdkIdentExpectedEmptyAccQuote)
        break
      of tkOpr, tkDot, tkDotDot, tkEquals, tkParLe..tkParDotRi:
        let lineinfo = p.lineInfo
        var accm = ""
        while p.tok.tokType in {tkOpr, tkDot, tkDotDot, tkEquals,
                                tkParLe..tkParDotRi}:
          accm.add $p.tok
          p.getTok
        result.idents.add (ident: p.lex.cache.getIdent(accm), line: lineinfo.line, col: lineinfo.col)
      of tkKeywords, tkSymbol, tkIntLit..tkCustomLit:
        result.idents.add (ident: p.lex.cache.getIdent($p.tok), line: p.lineInfo.line, col: p.lineInfo.col)
        p.getTok
      else:
        p.invalidExpectedIdent()
        break
    p.eat(tkAccent)
  else:
    p.invalidExpectedIdent()
    # BUGFIX: We must consume a token here to prevent endless loops!
    # But: this really sucks for idetools and keywords, so we don't do it
    # if it is a keyword:
    #if not isKeyword(p.tok.tokType): p.getTok
    result = p.emptyNode

proc colonOrEquals(p: var Parser, a: ParsedNode): ParsedNode =
  case p.tok.tokType:
  of tkColon:
    result = p.newNodeConsumingTok(pnkExprColonExpr)
    result.add a
    result.add parseExpr(p)
  of tkEquals:
    result = p.newNodeConsumingTok(pnkExprEqExpr)
    result.add a
    result.add parseExpr(p)
  else:
    result = a

proc exprColonEqExpr(p: var Parser): ParsedNode =
  #| exprColonEqExpr = expr (':'|'=' expr)?
  let a = parseExpr(p)
  if p.tok.tokType == tkDo:
    p.postExprBlocks(a)
  else:
    p.colonOrEquals(a)

proc exprList(p: var Parser, endTok: TokType, result: ParsedNode) =
  #| exprList = expr ^+ comma
  p.getTok
  p.optInd(result)
  # progress guaranteed
  while p.tok.tokType notin {endTok, tkEof}:
    var a = parseExpr(p)
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)

proc exprColonEqExprListAux(p: var Parser, endTok: TokType, result: ParsedNode) =
  assert endTok in {tkCurlyRi, tkCurlyDotRi, tkBracketRi, tkParRi}
  p.getTok
  p.flexComment(result)
  p.optPar
  # progress guaranteed
  while p.tok.tokType notin {endTok, tkEof}:
    var a = exprColonEqExpr(p)
    result.add a
    if p.tok.tokType != tkComma: break
    elif result.kind == pnkPar:
      result.transitionSonsKind(pnkTupleConstr)
    p.getTok
    p.skipComment(a)
  p.optPar
  p.eat(endTok)

proc exprColonEqExprList(p: var Parser, kind: range[pnkPar..pnkSqrBracket],
                         endTok: TokType): ParsedNode =
  #| exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
  result = p.newBracketNode(kind, p.tok)
  p.exprColonEqExprListAux(endTok, result)

proc dotExpr(p: var Parser, a: ParsedNode): ParsedNode =
  let dotTok = p.tok
  result = p.newNodeConsumingTok(pnkDotExpr, @[a])
  p.optInd(result)
  # result.add a
  let yTok = p.tok
  result.add p.parseSymbol(smAfterDot)
  if p.tok.tokType == tkBracketLeColon and p.tok.strongSpaceA <= 0:
    # rewrite 'x.y[:z]()' to 'y[z](x)'
    var x = p.newNode(pnkSqrBracketExpr, p.tok, @[result[1]])
    p.exprList(tkBracketRi, x)
    p.eat(tkBracketRi)
    var y = p.newNode(pnkCall, p.tok, @[x, result[0]])
    if p.tok.tokType == tkParLe and p.tok.strongSpaceA <= 0:
      p.exprColonEqExprListAux(tkParRi, y)
    result = y

proc dotLikeExpr(p: var Parser, a: ParsedNode): ParsedNode =
  result = p.newNode(pnkInfix, p.tok)
  p.optInd(result)
  result.add p.newIdentNode(p.tok)
  p.getTok
  result.add a
  result.add p.parseSymbol(smAfterDot)

proc qualifiedIdent(p: var Parser): ParsedNode =
  #| qualifiedIdent = symbol ('.' optInd symbol)?
  result = parseSymbol(p)
  if p.tok.tokType == tkDot:
    result = p.dotExpr(result)

proc setOrTableConstr(p: var Parser): ParsedNode =
  #| setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
  result = p.newNodeConsumingTok(pnkCurly)
  p.optInd(result)
  if p.tok.tokType == tkColon:
    p.getTok # skip ':'
    result.transitionSonsKind(pnkTableConstr)
  else:
    # progress guaranteed
    while p.tok.tokType notin {tkCurlyRi, tkEof}:
      var a = exprColonEqExpr(p)
      if a.kind == pnkExprColonExpr: result.transitionSonsKind(pnkTableConstr)
      result.add a
      if p.tok.tokType != tkComma: break
      p.getTok
      p.skipComment(a)
  p.optPar
  p.eat(tkCurlyRi) # skip '}'

proc parseCast(p: var Parser): ParsedNode =
  #| castExpr = 'cast' ('[' optInd typeDesc optPar ']' '(' optInd expr optPar ')') /
  #                    ('(' optInd exprColonEqExpr optPar ')')
  result = p.newNodeConsumingTok(pnkCast)
  case p.tok.tokType
  of tkBracketLe:
    p.getTok
    p.optInd(result)
    result.add parseTypeDesc(p)
    p.optPar
    p.eat(tkBracketRi)
    p.eat(tkParLe)
    p.optInd(result)
    result.add parseExpr(p)
  else:
    result.add p.emptyNode
    p.eat(tkParLe)
    p.optInd(result)
    result.add exprColonEqExpr(p)
  p.optPar
  p.eat(tkParRi)

proc parseGStrLit(p: var Parser, a: ParsedNode): ParsedNode =
  case p.tok.tokType
  of tkGStrLit:
    result = p.newNode(pnkCallStrLit, p.tok) # xxx: should the token param be the ident instead?
    result.add a
    result.add p.newLitNode(pnkRStrLit, p.tok)
    p.getTok
  of tkGTripleStrLit:
    result = p.newNode(pnkCallStrLit, p.tok) # xxx: should the token param be the ident instead?
    result.add a
    result.add p.newLitNode(pnkTripleStrLit, p.tok)
    p.getTok
  else:
    result = a

proc complexOrSimpleStmt(p: var Parser): ParsedNode
proc simpleExpr(p: var Parser, mode = pmNormal): ParsedNode
proc parseIfOrWhenExpr(p: var Parser, kind: ParsedNodeKind): ParsedNode

proc semiStmtList(p: var Parser, result: ParsedNode) =
  inc p.inSemiStmtList
  withInd(p):
    # Be lenient with the first stmt/expr
    result.add case p.tok.tokType
               of tkIf: p.parseIfOrWhenExpr(pnkIfStmt)
               of tkWhen: p.parseIfOrWhenExpr(pnkWhenStmt)
               else: complexOrSimpleStmt(p)

    while p.tok.tokType != tkEof:
      if p.tok.tokType == tkSemiColon:
        p.getTok
      if p.tok.tokType == tkParRi:
        break
      elif not (p.sameInd or p.realInd):
        p.invalidExpectedIdent()
      let a = complexOrSimpleStmt(p)
      case a.kind
      of pnkEmpty:
        p.invalidExpectedExpr()
        p.getTok
      else:
        result.add a
  dec p.inSemiStmtList
  result.transitionSonsKind(pnkStmtListExpr)

proc parsePar(p: var Parser): ParsedNode =
  #| parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
  #|         | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
  #|         | 'when' | 'var' | 'mixin'
  #| par = '(' optInd
  #|           ( &parKeyw (ifExpr / complexOrSimpleStmt) ^+ ';'
  #|           | ';' (ifExpr / complexOrSimpleStmt) ^+ ';'
  #|           | pragmaStmt
  #|           | simpleExpr ( ('=' expr (';' (ifExpr / complexOrSimpleStmt) ^+ ';' )? )
  #|                        | (':' expr (',' exprColonEqExpr     ^+ ',' )? ) ) )
  #|           optPar ')'
  #
  # unfortunately it's ambiguous: (expr: expr) vs (exprStmt); however a
  # leading ';' could be used to enforce a 'stmt' context ...
  result = p.newBracketNode(pnkPar, p.tok)
  p.getTok
  p.optInd(result)
  p.flexComment(result)
  case p.tok.tokType
  of tkDiscard, tkInclude, tkIf, tkWhile, tkCase,
     tkTry, tkDefer, tkFinally, tkExcept, tkBlock,
     tkConst, tkLet, tkWhen, tkVar, tkFor,
     tkMixin:
    # XXX 'bind' used to be an expression, so we exclude it here;
    # tests/reject/tbind2 fails otherwise.
    p.semiStmtList(result)
  of tkSemiColon:
    # '(;' enforces 'stmt' context:
    p.getTok
    p.optInd(result)
    p.semiStmtList(result)
  of tkCurlyDotLe:
    result.add parseStmtPragma(p)
  of tkParRi:
    # Empty tuple '()'
    result.transitionSonsKind(pnkTupleConstr)
  else:
    let a = simpleExpr(p)
    case p.tok.tokType
    of tkDo:
      result = p.postExprBlocks(a)
    of tkEquals:
      # special case: allow assignments
      let eqTok = p.tok
      p.getTok
      p.optInd(result)
      let b = parseExpr(p)
      result.add p.newNode(pnkAsgn, eqTok, @[a, b])
      if p.tok.tokType == tkSemiColon:
        p.semiStmtList(result)
    of tkSemiColon:
      # stmt context:
      result.add a
      p.semiStmtList(result)
    else:
      let a = p.colonOrEquals(a)
      if a.kind == pnkExprColonExpr:
        result.transitionSonsKind(pnkTupleConstr)
      result.add a
      if p.tok.tokType == tkComma:
        p.getTok
        p.skipComment(a)
        # (1,) produces a tuple expression:
        result.transitionSonsKind(pnkTupleConstr)
        # progress guaranteed
        while p.tok.tokType notin {tkParRi, tkEof}:
          var a = exprColonEqExpr(p)
          result.add a
          if p.tok.tokType != tkComma: break
          p.getTok
          p.skipComment(a)
  p.optPar
  p.eat(tkParRi)

proc identOrLiteral(p: var Parser, mode: PrimaryMode): ParsedNode =
  #| literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
  #|           | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
  #|           | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
  #|           | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
  #|           | CHAR_LIT | CUSTOM_NUMERIC_LIT
  #|           | NIL
  #| generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
  #| identOrLiteral = generalizedLit | symbol | literal
  #|                | par | arrayConstr | setOrTableConstr | tupleConstr
  #|                | castExpr
  #| tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
  #| arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
  case p.tok.tokType
  of tkSymbol, tkBuiltInMagics, tkOut:
    result = p.newIdentNode(p.tok)
    p.getTok
    result = p.parseGStrLit(result)
  of tkAccent:
    result = parseSymbol(p)       # literals
  of tkIntLit:       result = p.newLitNode(pnkIntLit,       p.tok); p.getTok
  of tkInt8Lit:      result = p.newLitNode(pnkInt8Lit,      p.tok); p.getTok
  of tkInt16Lit:     result = p.newLitNode(pnkInt16Lit,     p.tok); p.getTok
  of tkInt32Lit:     result = p.newLitNode(pnkInt32Lit,     p.tok); p.getTok
  of tkInt64Lit:     result = p.newLitNode(pnkInt64Lit,     p.tok); p.getTok
  of tkUIntLit:      result = p.newLitNode(pnkUIntLit,      p.tok); p.getTok
  of tkUInt8Lit:     result = p.newLitNode(pnkUInt8Lit,     p.tok); p.getTok
  of tkUInt16Lit:    result = p.newLitNode(pnkUInt16Lit,    p.tok); p.getTok
  of tkUInt32Lit:    result = p.newLitNode(pnkUInt32Lit,    p.tok); p.getTok
  of tkUInt64Lit:    result = p.newLitNode(pnkUInt64Lit,    p.tok); p.getTok
  of tkFloatLit:     result = p.newLitNode(pnkFloatLit,     p.tok); p.getTok
  of tkFloat32Lit:   result = p.newLitNode(pnkFloat32Lit,   p.tok); p.getTok
  of tkFloat64Lit:   result = p.newLitNode(pnkFloat64Lit,   p.tok); p.getTok
  of tkFloat128Lit:  result = p.newLitNode(pnkFloat128Lit,  p.tok); p.getTok
  of tkStrLit:       result = p.newLitNode(pnkStrLit,       p.tok); p.getTok
  of tkRStrLit:      result = p.newLitNode(pnkRStrLit,      p.tok); p.getTok
  of tkTripleStrLit: result = p.newLitNode(pnkTripleStrLit, p.tok); p.getTok
  of tkCharLit:      result = p.newLitNode(pnkCharLit,      p.tok); p.getTok
  of tkCustomLit:    result = p.newLitNode(pnkCustomLit,    p.tok); p.getTok
  of tkNil:          result = p.newNilLitNode(p.tok); p.getTok
  of tkParLe:
    # `()` constructor
    if mode in {pmTypeDesc, pmTypeDef}:
      result = p.exprColonEqExprList(pnkPar, tkParRi)
      if result.len == 0: # >0 is handled by exprColonEqExprList
        result.transitionSonsKind(pnkTupleConstr)
    else:
      result = parsePar(p)
  of tkCurlyLe:
    # `{}` constructor
    result = setOrTableConstr(p)
  of tkBracketLe:
    # `[]` constructor
    result = p.exprColonEqExprList(pnkSqrBracket, tkBracketRi)
  of tkCast:
    result = parseCast(p)
  else:
    p.invalidExpectedExpr()
    p.getTok  # we must consume a token here to prevent endless loops!
    result = p.emptyNode

proc namedParams(p: var Parser, callee: ParsedNode,
                 kind: ParsedNodeKind, endTok: TokType): ParsedNode =
  # progress guaranteed
  assert kind in {pnkCall, pnkSqrBracketExpr, pnkCurlyExpr}
  result = p.newNode(kind, p.tok, @[callee])
  p.exprColonEqExprListAux(endTok, result)

proc commandParam(p: var Parser, isFirstParam: var bool; mode: PrimaryMode): ParsedNode =
  result = if mode == pmTypeDesc:
             p.simpleExpr(mode)
           else:
             parseExpr(p)
  if p.tok.tokType == tkDo:
    result = p.postExprBlocks(result)
  elif p.tok.tokType == tkEquals and not isFirstParam:
    let lhs = result
    result = p.newNodeConsumingTok(pnkExprEqExpr)
    result.add lhs
    result.add parseExpr(p)
  isFirstParam = false

proc commandExpr(p: var Parser; r: ParsedNode; mode: PrimaryMode,
                 cmdTok: Token): ParsedNode =
  var isFirstParam = true
  # progress NOT guaranteed
  p.hasProgress = false
  p.newNode(pnkCommand, cmdTok,
    @[r, p.commandParam(isFirstParam, mode)])

proc isDotLike(tok: Token): bool =
  tok.tokType == tkOpr and tok.ident.s.len > 1 and
  tok.ident.s[0] == '.' and tok.ident.s[1] != '.'

proc primarySuffix(p: var Parser, r: ParsedNode,
                   baseIndent: int, mode: PrimaryMode): ParsedNode =
  #| primarySuffix = '(' (exprColonEqExpr comma?)* ')'
  #|       | '.' optInd symbol ('[:' exprList ']' ( '(' exprColonEqExpr ')' )?)? generalizedLit?
  #|       | DOTLIKEOP optInd symbol generalizedLit?
  #|       | '[' optInd exprColonEqExprList optPar ']'
  #|       | '{' optInd exprColonEqExprList optPar '}'
  #|       | &( '`'|IDENT|literal|'cast'|'addr'|'type') expr # command syntax
  result = r
  let startTok = p.tok

  # progress guaranteed
  while p.tok.indent < 0 or
       (p.tok.tokType == tkDot and p.tok.indent >= baseIndent):
    case p.tok.tokType
    of tkParLe:
      # progress guaranteed
      if p.tok.strongSpaceA > 0:
        # inside type sections, expressions such as `ref (int, bar)`
        # are parsed as a pnkCommand with a single tuple argument (pnkPar)
        result = if mode == pmTypeDef:
                   let tok = p.tok # fix for `refc` evals `p.primary` first
                   p.newNode(pnkCommand, tok,
                     @[r, p.primary(pmNormal)])
                 else:
                   p.commandExpr(result, mode, startTok)
        break
      else:
        result = p.namedParams(result, pnkCall, tkParRi)
        if result.len > 1 and result[1].kind == pnkExprColonExpr:
          result.transitionSonsKind(pnkObjConstr)
    of tkDot:
      # progress guaranteed
      result = p.parseGStrLit(p.dotExpr(result))
    of tkBracketLe:
      # progress guaranteed
      if p.tok.strongSpaceA > 0:
        result = p.commandExpr(result, mode, startTok)
        break
      else:
        result = p.namedParams(result, pnkSqrBracketExpr, tkBracketRi)
    of tkCurlyLe:
      # progress guaranteed
      if p.tok.strongSpaceA > 0:
        result = p.commandExpr(result, mode, startTok)
        break
      else:
        result = p.namedParams(result, pnkCurlyExpr, tkCurlyRi)
    of tkSymbol, tkAccent, tkIntLit..tkCustomLit, tkNil, tkCast,
       tkOpr, tkDotDot, tkVar, tkOut, tkStatic, tkType, tkEnum, tkTuple,
       tkObject, tkProc:
      # XXX: In type sections we allow the free application of the
      # command syntax, with the exception of expressions such as
      # `foo ref` or `foo ptr`. Unfortunately, these two are also
      # used as infix operators for the memory regions feature and
      # the current parsing rules don't play well here.
      let isDotLike2 = p.tok.isDotLike
      if isDotLike2 and p.lex.config.isDefined("nimPreviewDotLikeOps"):
        # synchronize with `tkDot` branch
        result = p.parseGStrLit(p.dotLikeExpr(result))
      else:
        if isDotLike2:
          p.currTokenDiag(pdkEnablePreviewDotOps)
        if p.inPragma == 0 and (isUnary(p.tok) or p.tok.tokType notin {tkOpr, tkDotDot}):
          # actually parsing {.push hints:off.} as {.push(hints:off).} is a sweet
          # solution, but pragmas.nim can't handle that
          # xxx: ^^ don't trust this recommendation, it needs a lot of vetting
          result = p.commandExpr(result, mode, startTok)
        break
    else:
      break

proc parseOperators(p: var Parser, headNode: ParsedNode,
                    limit: int, mode: PrimaryMode): ParsedNode =
  result = headNode
  # expand while operators have priorities higher than 'limit'
  var opPrec = getPrecedence(p.tok)
  let modeB = if mode == pmTypeDef: pmTypeDesc else: mode
  # the operator itself must not start on a new line:
  # progress guaranteed
  while opPrec >= limit and p.tok.indent < 0 and not isUnary(p.tok):
    checkBinary(p)
    let leftAssoc = ord(not isRightAssociative(p.tok))
    var
      a = p.newNode(pnkInfix, p.tok)
      opNode = p.newIdentNode(p.tok) # skip operator: <-- why skip it?
    p.getTok
    p.flexComment(a)
    p.optPar
    a.add opNode
    a.add result
    # read sub-expression with higher priority:
    a.add p.simpleExprAux(opPrec + leftAssoc, modeB)
    result = a
    opPrec = getPrecedence(p.tok)

proc simpleExprAux(p: var Parser, limit: int, mode: PrimaryMode): ParsedNode =
  result = p.primary(mode)
  if p.tok.tokType == tkCurlyDotLe and p.validInd and mode == pmNormal:
    let tok = p.tok # fix for `refc` evals `p.parsePragma` first
    result = p.newNode(pnkPragmaExpr, tok, @[result, p.parsePragma()])
  result = p.parseOperators(result, limit, mode)

proc simpleExpr(p: var Parser, mode = pmNormal): ParsedNode =
  result = p.simpleExprAux(-1, mode)

proc parsePragma(p: var Parser): ParsedNode =
  #| pragma = '{.' optInd (exprColonEqExpr comma?)* optPar ('.}' | '}')
  result = p.newNodeConsumingTok(pnkPragma)
  inc p.inPragma
  p.optInd(result)
  while p.tok.tokType notin {tkCurlyDotRi, tkCurlyRi, tkEof}:
    p.hasProgress = false
    var a = exprColonEqExpr(p)
    if not p.hasProgress: break
    result.add a
    if p.tok.tokType == tkComma:
      p.getTok
      p.skipComment(a)
  p.optPar
  if p.tok.tokType in {tkCurlyDotRi, tkCurlyRi}:
    p.getTok
  else:
    p.invalidExpectedTokenMissing(tkCurlyDotRi)
  dec p.inPragma

proc identVis(p: var Parser; allowDot=false): ParsedNode =
  #| identVis = symbol OPR?  # postfix position
  #| identVisDot = symbol '.' optInd symbol OPR?
  let a = parseSymbol(p)
  if p.tok.tokType == tkOpr:
    let tok = p.tok # fix for `refc` evals `p.newIdentNode` first
    result = p.newNode(pnkPostfix, tok,
      @[p.newIdentNode(p.tok), a])
    p.getTok
  elif p.tok.tokType == tkDot and allowDot:
    result = p.dotExpr(a)
  else:
    result = a

proc identWithPragma(p: var Parser; allowDot=false): ParsedNode =
  #| identWithPragma = identVis pragma?
  #| identWithPragmaDot = identVisDot pragma?
  let a = p.identVis(allowDot)
  if p.tok.tokType == tkCurlyDotLe:
    let tok = p.tok
    p.newNode(pnkPragmaExpr, tok, @[a, parsePragma(p)])
  else:
    a

type
  DeclaredIdentFlag = enum
    withPragma,               # identifier may have pragma
    withBothOptional          # both ':' and '=' parts are optional
    withDot                   # allow 'var ident.ident = value'
  DeclaredIdentFlags = set[DeclaredIdentFlag]

proc parseIdentColonEquals(p: var Parser, flags: DeclaredIdentFlags): ParsedNode =
  #| declColonEquals = identWithPragma (comma identWithPragma)* comma?
  #|                   (':' optInd typeDesc)? ('=' optInd expr)?
  #| identColonEquals = IDENT (comma IDENT)* comma?
  #|      (':' optInd typeDesc)? ('=' optInd expr)?)
  var a: ParsedNode
  result = p.newNode(pnkIdentDefs, p.tok)
  # progress guaranteed
  while true:
    case p.tok.tokType
    of tkSymbol, tkAccent,
        tkKeywords:
        # `tkKeywords` is an error case, definition parsing will emit a
        # diagnostic and guarantee progress
      if withPragma in flags: a = p.identWithPragma(allowDot=withDot in flags)
      else: a = parseSymbol(p)
      if a.kind == pnkEmpty: return
    else: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  if p.tok.tokType == tkColon:
    p.getTok
    p.optInd(result)
    result.add parseTypeDesc(p)
  else:
    result.add p.newEmptyParsedNode()
    if p.tok.tokType != tkEquals and withBothOptional notin flags:
      p.invalidExpectedTokenMissing(tkColon, tkEquals)
  if p.tok.tokType == tkEquals:
    p.getTok
    p.optInd(result)
    result.add parseExpr(p)
  else:
    result.add p.newEmptyParsedNode()

proc parseTuple(p: var Parser, indentAllowed = false): ParsedNode =
  #| tupleDecl = 'tuple'
  #|     '[' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']' |
  #|     COMMENT? (IND{>} identColonEquals (IND{=} identColonEquals)*)?
  result = p.newNodeConsumingTok(pnkTupleTy)
  if p.tok.tokType == tkBracketLe:
    p.getTok
    p.optInd(result)
    # progress guaranteed
    while p.tok.tokType in {tkSymbol, tkAccent}:
      var a = p.parseIdentColonEquals({})
      result.add a
      if p.tok.tokType notin {tkComma, tkSemiColon}: break
      p.getTok
      p.skipComment(a)
    p.optPar
    p.eat(tkBracketRi)
  elif indentAllowed:
    p.skipComment(result)
    if p.realInd:
      withInd(p):
        p.rawSkipComment(result)
        # progress guaranteed
        while true:
          case p.tok.tokType
          of tkSymbol, tkAccent:
            var a = p.parseIdentColonEquals({})
            if p.tok.indent < 0 or p.tok.indent >= p.currInd:
              p.rawSkipComment(a)
            result.add a
          of tkEof: break
          else:
            p.invalidExpectedIdent()
            break
          if not p.sameInd: break
  elif p.tok.tokType == tkParLe:
    p.currTokenDiag(pdkTupleTypeWithPar)
  else:
    result = p.newNode(pnkTupleClassTy, result.token) # xxx: cheap transition

proc parseParamList(p: var Parser, retColon = true): ParsedNode =
  #| paramList = '(' declColonEquals ^* (comma/semicolon) ')'
  #| paramListArrow = paramList? ('->' optInd typeDesc)?
  #| paramListColon = paramList? (':' optInd typeDesc)?
  result = p.newNode(pnkFormalParams, p.tok)
  result.add p.emptyNode # return type
  let hasParLe = p.tok.tokType == tkParLe and p.tok.indent < 0
  if hasParLe:
    p.getTok
    p.optInd(result)
    # progress guaranteed
    var a: ParsedNode
    while true:
      case p.tok.tokType
      of tkSymbol, tkAccent:
        a = p.parseIdentColonEquals({withBothOptional, withPragma})
      of tkParRi:
        break
      of tkVar:
        p.currTokenDiag(pdkMisplacedParameterVar)
        break
      else:
        p.invalidExpectedTokenMissing(tkParRi)
        break
      result.add a
      if p.tok.tokType notin {tkComma, tkSemiColon}: break
      p.getTok
      p.skipComment(a)
    p.optPar
    p.eat(tkParRi)
  let hasRet = retColon and p.tok.tokType == tkColon or
               p.tok.tokType == tkOpr and p.tok.ident.s == "->"
  if hasRet and p.tok.indent < 0:
    p.getTok
    p.optInd(result)
    result[0] = parseTypeDesc(p)
  elif not retColon and not hasParLe:
    # Mark as "not there" in order to mark for deprecation in the semantic pass:
    result = p.emptyNode

proc optPragmas(p: var Parser): ParsedNode =
  if p.tok.tokType == tkCurlyDotLe and p.validInd:
    parsePragma(p)
  else:
    p.emptyNode

proc parseDoBlock(p: var Parser; token: Token): ParsedNode =
  #| doBlock = 'do' paramListArrow pragma? colcom stmt
  let
    params = p.parseParamList(retColon=false)
    pragmas = optPragmas(p)
  p.colcom(nil)
  if params.kind == pnkEmpty and pragmas.kind == pnkEmpty:
    parseStmt(p)
  else:
    newProcNode(
      pnkDo,
      p.lex.fileIdx,
      toParsedToken(token),
      body = parseStmt(p),
      params = if params.kind != pnkEmpty: params
               else: p.newNode(pnkFormalParams, p.tok, @[p.emptyNode]),
      name = p.emptyNode,
      pattern = p.emptyNode,
      genericParams = p.emptyNode,
      pragmas = pragmas,
      exceptions = p.emptyNode
    )

proc parseProcExpr(p: var Parser; isExpr: bool; kind: ParsedNodeKind): ParsedNode =
  #| routineExpr = ('proc' | 'func' | 'iterator') paramListColon pragma? ('=' COMMENT? stmt)?
  # either a proc type or a anonymous proc
  let token = p.tok
  p.getTok
  let
    hasSignature = p.tok.tokType in {tkParLe, tkColon} and p.tok.indent < 0
    params = parseParamList(p)
    pragmas = optPragmas(p)
  if p.tok.tokType == tkEquals and isExpr:
    p.getTok
    p.skipComment(result)
    result = newProcNode(
      kind,
      p.lex.fileIdx,
      toParsedToken(token),
      body = parseStmt(p),
      params = params,
      name = p.emptyNode,
      pattern = p.emptyNode,
      genericParams = p.emptyNode,
      pragmas = pragmas,
      exceptions = p.emptyNode)
  else:
    result = p.newNode(pnkProcTy, token = token)
    if hasSignature:
      result.add params
      if kind == pnkFuncDef:
        p.currTokenDiag(pdkFuncNotAllowed)
      result.add pragmas

proc isExprStart(p: Parser): bool =
  p.tok.tokType in {tkSymbol, tkAccent, tkOpr, tkNot, tkNil, tkCast, tkIf, tkFor,
     tkProc, tkFunc, tkIterator, tkBind, tkParLe, tkBracketLe, tkCurlyLe,
     tkIntLit..tkCustomLit, tkVar, tkRef, tkPtr,
     tkTuple, tkObject, tkWhen, tkCase, tkOut} + tkBuiltInMagics

proc parseSymbolList(p: var Parser, result: ParsedNode) =
  # progress guaranteed
  while true:
    var s = p.parseSymbol(smAllowNil)
    if s.kind == pnkEmpty: break
    result.add s
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(s)

proc parseTypeDescKAux(p: var Parser, kind: ParsedNodeKind,
                       mode: PrimaryMode): ParsedNode =
  result = p.newNodeConsumingTok(kind)
  if p.tok.indent != -1 and p.tok.indent <= p.currInd: return
  p.optInd(result)
  if not isOperator(p.tok) and isExprStart(p):
    result.add p.primary(mode)
  if kind == pnkDistinctTy and p.tok.tokType == tkSymbol:
    # XXX document this feature!
    let nodeKind =
      case p.tok.ident.s
      of "with":    pnkWith
      of "without": pnkWithout
      else:         return
    let list = p.newNodeConsumingTok(nodeKind)
    result.add list
    p.parseSymbolList(list)

proc parseVarTuple(p: var Parser): ParsedNode

proc parseFor(p: var Parser): ParsedNode =
  #| forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
  #| forExpr = forStmt
  result = p.newNode(pnkForStmt, p.tok)
  p.getTokNoInd
  if p.tok.tokType == tkParLe:
    result.add parseVarTuple(p)
  else:
    var a = identWithPragma(p)
    result.add a
    while p.tok.tokType == tkComma:
      p.getTok
      p.optInd(a)
      if p.tok.tokType == tkParLe:
        result.add parseVarTuple(p)
        break
      a = identWithPragma(p)
      result.add a
  p.eat(tkIn)
  result.add parseExpr(p)
  p.colcom(result)
  result.add parseStmt(p)

proc parseExpr(p: var Parser): ParsedNode =
  #| expr = (blockExpr
  #|       | ifExpr
  #|       | whenExpr
  #|       | caseStmt
  #|       | forExpr
  #|       | tryExpr)
  #|       / simpleExpr
  case p.tok.tokType:
    of tkBlock: result = parseBlock(p)
    of tkIf: result = p.parseIfOrWhenExpr(pnkIfExpr)
    of tkFor: result = parseFor(p)
    of tkWhen: result = p.parseIfOrWhenExpr(pnkWhenExpr)
    of tkCase: result = parseCase(p)
    of tkTry: result = p.parseTry(isExpr=true)
    else: result = simpleExpr(p)

proc parseEnum(p: var Parser): ParsedNode
proc parseObject(p: var Parser): ParsedNode
proc parseTypeClass(p: var Parser): ParsedNode

proc primary(p: var Parser, mode: PrimaryMode): ParsedNode =
  #| primary = operatorB primary primarySuffix* |
  #|           tupleDecl | routineExpr | enumDecl
  #|           objectDecl | conceptDecl | ('bind' primary)
  #|           ('var' | 'out' | 'ref' | 'ptr' | 'distinct') primary
  #|         /  prefixOperator* identOrLiteral primarySuffix*
  if isOperator(p.tok):
    # Note 'sigil like' operators are currently not reflected in the grammar
    # and should be removed for Nim 2.0, I don't think anybody uses them.
    let isSigil = isSigilLike(p.tok)
    var a = p.newIdentNode(p.tok)
    result = p.newNodeConsumingTok(pnkPrefix, @[a])
    p.optInd(a)
    if isSigil:
      #XXX prefix operators
      let baseInd = p.lex.currLineIndent
      result.add p.primary(pmSkipSuffix)
      result = p.primarySuffix(result, baseInd, mode)
    else:
      result.add p.primary(pmNormal)
    return

  case p.tok.tokType
  of tkTuple: result = p.parseTuple(mode == pmTypeDef)
  of tkProc: result = p.parseProcExpr(mode notin {pmTypeDesc, pmTypeDef}, pnkLambda)
  of tkFunc: result = p.parseProcExpr(mode notin {pmTypeDesc, pmTypeDef}, pnkFuncDef)
  of tkIterator:
    result = p.parseProcExpr(mode notin {pmTypeDesc, pmTypeDef}, pnkLambda)
    if result.kind == pnkLambda: result.transitionSonsKind(pnkIteratorDef)
    else: result.transitionSonsKind(pnkIteratorTy)
  of tkEnum:
    if mode == pmTypeDef:
      result = parseEnum(p)
    else:
      result = p.newNodeConsumingTok(pnkEnumTy)
  of tkObject:
    if mode == pmTypeDef:
      result = parseObject(p)
    else:
      result = p.newNodeConsumingTok(pnkObjectTy)
  of tkConcept:
    if mode == pmTypeDef:
      result = parseTypeClass(p)
    else:
      p.currTokenDiag(pdkConceptNotInType)
  of tkBind:
    result = p.newNodeConsumingTok(pnkBind)
    p.optInd(result)
    result.add p.primary(pmNormal)
  of tkVar: result = p.parseTypeDescKAux(pnkVarTy, mode)
  of tkOut:
    # I like this parser extension to be in 1.4 as it still might turn out
    # useful in the long run.
    result = p.parseTypeDescKAux(pnkMutableTy, mode)
  of tkRef: result = p.parseTypeDescKAux(pnkRefTy, mode)
  of tkPtr: result = p.parseTypeDescKAux(pnkPtrTy, mode)
  of tkDistinct: result = p.parseTypeDescKAux(pnkDistinctTy, mode)
  else:
    let baseInd = p.lex.currLineIndent
    result = p.identOrLiteral(mode)
    if mode != pmSkipSuffix:
      result = p.primarySuffix(result, baseInd, mode)

proc binaryNot(p: var Parser; a: ParsedNode): ParsedNode =
  if p.tok.tokType == tkNot:
    let notOpr = p.newIdentNode(p.tok)
    p.getTok
    p.optInd(notOpr)
    let tok = p.tok # fix for `refc` evals `parseExpr` first
    result = p.newNode(pnkInfix, tok, @[notOpr, a, parseExpr(p)])
  else:
    result = a

proc parseTypeDesc(p: var Parser): ParsedNode =
  #| typeDesc = simpleExpr ('not' expr)?
  p.binaryNot(p.simpleExpr(pmTypeDesc))

proc parseTypeDefAux(p: var Parser): ParsedNode =
  #| typeDefAux = simpleExpr ('not' expr)?
  p.binaryNot(p.simpleExpr(pmTypeDef))  

proc postExprBlocks(p: var Parser, x: ParsedNode): ParsedNode =
  #| postExprBlocks = ':' stmt? ( IND{=} doBlock
  #|                            | IND{=} 'of' exprList ':' stmt
  #|                            | IND{=} 'elif' expr ':' stmt
  #|                            | IND{=} 'except' exprList ':' stmt
  #|                            | IND{=} 'finally' ':' stmt
  #|                            | IND{=} 'else' ':' stmt )*
  result = x
  if p.tok.indent >= 0: return

  var
    openingParams = p.emptyNode
    openingPragmas = p.emptyNode
    beforeParamsTok: Token       ## used when we have a zero param do/lambda

  if p.tok.tokType == tkDo:
    p.getTok
    beforeParamsTok = p.tok
    openingParams = p.parseParamList(retColon=false)
    openingPragmas = optPragmas(p)

  if p.tok.tokType == tkColon:
    # make `result` a call if it isn't one already
    result =
      case result.kind
      of pnkCallKinds:
        result
      of pnkEmpty:
        newParsedNode(pnkCall, p.lex.fileIdx, toParsedToken(p.tok), @[result])
      else:
        newParsedNode(pnkCall, result.fileIndex, result.getToken, @[result])

    p.getTok
    p.skipComment(result)
    if p.tok.tokType notin {tkOf, tkElif, tkElse, tkExcept, tkFinally}:
      let tok = p.tok # fix for `refc` evals `parseStmt` first
      var stmtList = p.newNode(pnkStmtList, tok, @[parseStmt(p)])
      # to keep backwards compatibility (see tests/vm/tstringnil)
      if stmtList[0].kind == pnkStmtList: stmtList = stmtList[0]

      result.add if openingParams.kind == pnkEmpty and
                    openingPragmas.kind == pnkEmpty:
                   stmtList
                 else:
                   newProcNode(
                     pnkDo,
                     p.lex.fileIdx,
                     stmtList.token,
                     body = stmtList,
                     params =
                      if openingParams.kind != pnkEmpty:
                        openingParams
                      else:
                        p.newNode(pnkFormalParams, beforeParamsTok, @[p.emptyNode]),
                     name = p.emptyNode,
                     pattern = p.emptyNode,
                     genericParams = p.emptyNode,
                     pragmas = openingPragmas,
                     exceptions = p.emptyNode
                   )

    while p.sameInd:
      var nextBlock: ParsedNode
      let nextToken = p.tok.tokType
      if nextToken == tkDo:
        let tok = p.tok
        p.getTok
        nextBlock = p.parseDoBlock(tok)
      else:
        case nextToken
        of tkOf:
          nextBlock = p.newNode(pnkOfBranch, p.tok)
          p.exprList(tkColon, nextBlock)
        of tkElif:
          nextBlock = p.newNodeConsumingTok(pnkElifBranch)
          p.optInd(nextBlock)
          nextBlock.add parseExpr(p)
        of tkExcept:
          nextBlock = p.newNode(pnkExceptBranch, p.tok)
          p.exprList(tkColon, nextBlock)
        of tkFinally:
          nextBlock = p.newNodeConsumingTok(pnkFinally)
        of tkElse:
          nextBlock = p.newNodeConsumingTok(pnkElse)
        else: break
        p.eat(tkColon)
        nextBlock.add parseStmt(p)

      result.add nextBlock

      if nextBlock.kind in {pnkElse, pnkFinally}: break
  else:
    if openingParams.kind != pnkEmpty:
      p.invalidExpectedTokenMissing(tkColon)

proc parseExprStmt(p: var Parser): ParsedNode =
  #| exprStmt = simpleExpr
  #|          (( '=' optInd expr colonBody? )
  #|          / ( expr ^+ comma
  #|              postExprBlocks
  #|            ))?
  var a = simpleExpr(p)
  if p.tok.tokType == tkEquals:
    result = p.newNodeConsumingTok(pnkAsgn)
    p.optInd(result)
    result.add a
    result.add p.postExprBlocks(parseExpr(p))
  else:
    # simpleExpr parsed 'p a' from 'p a, b'?
    var isFirstParam = false
    if p.tok.indent < 0 and p.tok.tokType == tkComma and a.kind == pnkCommand:
      result = a
      while true:
        p.getTok
        p.optInd(result)
        result.add p.commandParam(isFirstParam, pmNormal)
        if p.tok.tokType != tkComma: break
    elif p.tok.indent < 0 and isExprStart(p):
      result = p.newNode(pnkCommand, a.getToken, @[a])
      while true:
        result.add p.commandParam(isFirstParam, pmNormal)
        if p.tok.tokType != tkComma: break
        p.getTok
        p.optInd(result)
    else:
      result = a
    result = p.postExprBlocks(result)

proc parseImport(p: var Parser, kind: ParsedNodeKind): ParsedNode =
  #| importStmt = 'import' optInd expr
  #|               ((comma expr)*
  #|               / 'except' optInd (expr ^+ comma))
  #| exportStmt = 'export' optInd expr
  #|               ((comma expr)*
  #|               / 'except' optInd (expr ^+ comma))
  result = p.newNodeConsumingTok(kind) # `import` or `export`
  p.optInd(result)
  result.add parseExpr(p)
  if p.tok.tokType in {tkComma, tkExcept}:
    if p.tok.tokType == tkExcept:
      let exceptKind =
        case kind
        of pnkImportStmt: pnkImportExceptStmt
        of pnkExportStmt: pnkExportExceptStmt
        else: unreachable()
      result.transitionSonsKind(exceptKind)
    p.getTok
    p.optInd(result)
    while true:
      # was: while p.tok.tokType notin {tkEof, tkSad, tkDed}:
      p.hasProgress = false
      let a = parseExpr(p)
      if a.kind == pnkEmpty or not p.hasProgress: break
      result.add a
      if p.tok.tokType != tkComma: break
      p.getTok
      p.optInd(a)
  #expectNl(p)

proc parseIncludeStmt(p: var Parser): ParsedNode =
  #| includeStmt = 'include' optInd expr ^+ comma
  result = p.newNodeConsumingTok(pnkIncludeStmt)
  p.optInd(result)
  while true:
    # was: while p.tok.tokType notin {tkEof, tkSad, tkDed}:
    p.hasProgress = false
    var a = parseExpr(p)
    if a.kind == pnkEmpty or not p.hasProgress: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  #expectNl(p)

proc parseFromStmt(p: var Parser): ParsedNode =
  #| fromStmt = 'from' expr 'import' optInd expr (comma expr)*
  result = p.newNodeConsumingTok(pnkFromStmt)
  p.optInd(result)
  result.add parseExpr(p)
  #p.optInd(a)
  p.eat(tkImport)
  p.optInd(result)
  while true:
    # p.tok.tokType notin {tkEof, tkSad, tkDed}:
    p.hasProgress = false
    let a = parseExpr(p)
    if a.kind == pnkEmpty or not p.hasProgress: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  #expectNl(p)

proc parseReturnOrRaise(p: var Parser, kind: ParsedNodeKind): ParsedNode =
  #| returnStmt = 'return' optInd expr?
  #| raiseStmt = 'raise' optInd expr?
  #| yieldStmt = 'yield' optInd expr?
  #| discardStmt = 'discard' optInd expr?
  #| breakStmt = 'break' optInd expr?
  #| continueStmt = 'continue' optInd expr?
  result = p.newNodeConsumingTok(kind)
  result.add if p.tok.tokType == tkComment:
               p.skipComment(result)
               p.emptyNode
             elif p.tok.indent >= 0 and p.tok.indent <= p.currInd or
                  not isExprStart(p):
               # NL terminates:
               p.emptyNode
             else:
               p.postExprBlocks(parseExpr(p))

proc parseIfOrWhen(p: var Parser, kind: ParsedNodeKind): ParsedNode =
  #| condStmt = expr colcom stmt COMMENT?
  #|            (IND{=} 'elif' expr colcom stmt)*
  #|            (IND{=} 'else' colcom stmt)?
  #| ifStmt = 'if' condStmt
  #| whenStmt = 'when' condStmt
  result = p.newNode(kind, p.tok)
  while true:
    p.getTok                 # skip `if`, `when`, `elif`
    var branch = p.newNode(pnkElifBranch, p.tok)
    p.optInd(branch)
    branch.add parseExpr(p)
    p.colcom(branch)
    branch.add parseStmt(p)
    p.skipComment(branch)
    result.add branch
    if p.tok.tokType != tkElif or not p.sameOrNoInd: break
  if p.tok.tokType == tkElse and p.sameOrNoInd:
    var branch = p.newNodeConsumingTok(pnkElse)
    p.colcom(branch)
    branch.add parseStmt(p)
    result.add branch

proc parseIfOrWhenExpr(p: var Parser, kind: ParsedNodeKind): ParsedNode =
  #| condExpr = expr colcom expr optInd
  #|         ('elif' expr colcom expr optInd)*
  #|          'else' colcom expr
  #| ifExpr = 'if' condExpr
  #| whenExpr = 'when' condExpr
  result = p.newNode(kind, p.tok)
  while true:
    p.getTok                 # skip `if`, `when`, `elif`
    var branch = p.newNode(pnkElifExpr, p.tok)
    p.optInd(branch)
    branch.add parseExpr(p)
    p.colcom(branch)
    branch.add parseStmt(p)
    p.skipComment(branch)
    result.add branch
    if p.tok.tokType != tkElif: break
  if p.tok.tokType == tkElse:
    var branch = p.newNodeConsumingTok(pnkElseExpr)
    p.colcom(branch)
    branch.add parseStmt(p)
    result.add branch

proc parseWhile(p: var Parser): ParsedNode =
  #| whileStmt = 'while' expr colcom stmt
  result = p.newNode(pnkWhileStmt, p.tok)
  p.getTok
  p.optInd(result)
  result.add parseExpr(p)
  p.colcom(result)
  result.add parseStmt(p)

proc parseCase(p: var Parser): ParsedNode =
  #| ofBranch = 'of' exprList colcom stmt
  #| ofBranches = ofBranch (IND{=} ofBranch)*
  #|                       (IND{=} 'elif' expr colcom stmt)*
  #|                       (IND{=} 'else' colcom stmt)?
  #| caseStmt = 'case' expr ':'? COMMENT?
  #|             (IND{>} ofBranches DED
  #|             | IND{=} ofBranches)
  result = p.newNodeConsumingTok(pnkCaseStmt)
  result.add parseExpr(p)
  if p.tok.tokType == tkColon: p.getTok
  p.skipComment(result)

  let oldInd = p.currInd
  let wasIndented = p.realInd
  if wasIndented:
    p.currInd = p.tok.indent

  var inElif = false
  while p.sameInd:
    var b: ParsedNode
    case p.tok.tokType
    of tkOf:
      if inElif: break
      b = p.newNode(pnkOfBranch, p.tok)
      p.exprList(tkColon, b)
    of tkElif:
      inElif = true
      b = p.newNodeConsumingTok(pnkElifBranch)
      p.optInd(b)
      b.add parseExpr(p)
    of tkElse:
      b = p.newNodeConsumingTok(pnkElse)
    else: break
    p.colcom(b)
    b.add parseStmt(p)
    result.add b
    if b.kind == pnkElse: break

  if wasIndented:
    p.currInd = oldInd

proc parseTry(p: var Parser; isExpr: bool): ParsedNode =
  #| tryStmt = 'try' colcom stmt &(IND{=}? 'except'|'finally')
  #|            (IND{=}? 'except' exprList colcom stmt)*
  #|            (IND{=}? 'finally' colcom stmt)?
  #| tryExpr = 'try' colcom stmt &(optInd 'except'|'finally')
  #|            (optInd 'except' exprList colcom stmt)*
  #|            (optInd 'finally' colcom stmt)?
  result = p.newNodeConsumingTok(pnkTryStmt)
  p.colcom(result)
  result.add parseStmt(p)
  var b: ParsedNode = nil
  while p.sameOrNoInd or isExpr:
    case p.tok.tokType
    of tkExcept:
      b = p.newNode(pnkExceptBranch, p.tok)
      p.exprList(tkColon, b)
    of tkFinally:
      b = p.newNodeConsumingTok(pnkFinally)
    else: break
    p.colcom(b)
    b.add parseStmt(p)
    result.add b
  if b == nil:
    p.invalidExpectedTokenMissing(tkExcept)

proc parseExceptBlock(p: var Parser, kind: ParsedNodeKind): ParsedNode =
  result = p.newNodeConsumingTok(kind)
  p.colcom(result)
  result.add parseStmt(p)

proc parseBlock(p: var Parser): ParsedNode =
  #| blockStmt = 'block' symbol? colcom stmt
  #| blockExpr = 'block' symbol? colcom stmt
  result = p.newNode(pnkBlockStmt, p.tok)
  p.getTokNoInd
  result.add if p.tok.tokType == tkColon: p.emptyNode
             else: parseSymbol(p)
  p.colcom(result)
  result.add parseStmt(p)

proc parseStaticOrDefer(p: var Parser; k: ParsedNodeKind): ParsedNode =
  #| staticStmt = 'static' colcom stmt
  #| deferStmt = 'defer' colcom stmt
  result = p.newNodeConsumingTok(k)
  p.colcom(result)
  result.add parseStmt(p)

proc parseAsm(p: var Parser): ParsedNode =
  #| asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
  result = p.newNode(pnkAsmStmt, p.tok)
  p.getTokNoInd
  result.add if p.tok.tokType == tkCurlyDotLe: parsePragma(p)
             else: p.emptyNode
  case p.tok.tokType
  of tkStrLit: result.add p.newLitNode(pnkStrLit, p.tok)
  of tkRStrLit: result.add p.newLitNode(pnkRStrLit, p.tok)
  of tkTripleStrLit: result.add p.newLitNode(pnkTripleStrLit, p.tok)
  else:
    p.finalizeDiag:
      ParseDiag(location: p.lineInfo,
                instLoc: instLoc(-1),
                kind: pdkAsmStmtExpectsStrLit,
                found: p.tok)
    result.add p.emptyNode
    return
  p.getTok

proc parseGenericParam(p: var Parser): ParsedNode =
  #| genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
  var a: ParsedNode
  result = p.newNode(pnkIdentDefs, p.tok)
  # progress guaranteed
  while true:
    case p.tok.tokType
    of tkIn, tkOut:
      let x = p.lex.cache.getIdent(if p.tok.tokType == tkIn: "in" else: "out")
      a = p.newNodeConsumingTok(pnkPrefix, @[p.newIdentNode(p.tok)])
      a.add parseSymbol(p)
    of tkSymbol, tkAccent:
      a = parseSymbol(p)
      if a.kind == pnkEmpty: return
    else: break
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  result.add if p.tok.tokType == tkColon:
               p.getTok
               p.optInd(result)
               parseExpr(p)
             else:
               p.emptyNode
  result.add if p.tok.tokType == tkEquals:
               p.getTok
               p.optInd(result)
               parseExpr(p)
             else:
               p.emptyNode

proc parseGenericParamList(p: var Parser): ParsedNode =
  #| genericParamList = '[' optInd
  #|   genericParam ^* (comma/semicolon) optPar ']'
  result = p.newNodeConsumingTok(pnkGenericParams)
  p.optInd(result)
  # progress guaranteed
  while p.tok.tokType in {tkSymbol, tkAccent, tkIn, tkOut}:
    var a = parseGenericParam(p)
    result.add a
    if p.tok.tokType notin {tkComma, tkSemiColon}: break
    p.getTok
    p.skipComment(a)
  p.optPar
  p.eat(tkBracketRi)

proc parsePattern(p: var Parser): ParsedNode =
  #| pattern = '{' stmt '}'
  p.eat(tkCurlyLe)
  result = parseStmt(p)
  p.eat(tkCurlyRi)

proc parseRoutine(p: var Parser, kind: ParsedNodeKind): ParsedNode =
  #| indAndComment = (IND{>} COMMENT)? | COMMENT?
  #| routine = optInd identVis pattern? genericParamList?
  #|   paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
  result = p.newNodeConsumingTok(kind)
  p.optInd(result)

  result.add identVis(p)
  result.add if p.validInd and p.tok.tokType == tkCurlyLe:
               p.parsePattern
             else:
               p.emptyNode
  result.add if p.validInd and p.tok.tokType == tkBracketLe:
               p.parseGenericParamList
             else:
               p.emptyNode
  result.add p.parseParamList
  result.add if p.validInd and p.tok.tokType == tkCurlyDotLe:
               p.parsePragma
             else:
               p.emptyNode
  # empty exception tracking:
  result.add p.emptyNode
  let maybeMissEquals = p.tok.tokType != tkEquals
  result.add if p.validInd and not maybeMissEquals:
               p.getTok
               p.skipComment(result)
               parseStmt(p)
             else:
               p.emptyNode
  p.indAndComment(result, maybeMissEquals)
  let body = result[^1]
  if body.kind == pnkStmtList and body.len > 0 and
     body[0].kind != pnkCommentStmt and body[0].comment.len > 0:
    if result.comment.len == 0:
      # proc fn*(a: int): int = a ## foo
      # => moves comment `foo` to `fn`
      result.comment = body[0].comment
      body[0].comment = ""
    #else:
    #  assert false, p.lex.config$body.info # avoids hard to track bugs, fail early.
    # Yeah, that worked so well. There IS a bug in this logic, now what?


proc newCommentStmt(p: var Parser): ParsedNode =
  #| commentStmt = COMMENT
  result = p.newNode(pnkCommentStmt, p.tok)
  result.comment = p.tok.literal
  p.getTok

proc parseSection(p: var Parser, kind: ParsedNodeKind,
                  defparser: proc (p: var Parser): ParsedNode {.nimcall.}): ParsedNode =
  #| section(RULE) = COMMENT? RULE / (IND{>} (RULE / COMMENT)^+IND{=} DED)
  result = p.newNode(kind, p.tok)
  if kind != pnkTypeSection: p.getTok
  p.skipComment(result)
  if p.realInd:
    withInd(p):
      p.skipComment(result)
      # progress guaranteed
      while p.sameInd:
        case p.tok.tokType
        of tkSymbol, tkAccent, tkParLe,
            tkKeywords:
          # `tkKeywords` is an error case, definition parsing will emit a
          # diagnostic and guarantee progress
          var a = defparser(p)
          p.skipComment(a)
          result.add a
        of tkComment:
          var a = newCommentStmt(p)
          result.add a
        else:
          p.invalidExpectedIdent()
          break
    if result.len == 0:
      p.invalidExpectedIdent()
  elif p.tok.tokType in {tkSymbol, tkAccent, tkParLe} + tkKeywords and
        p.tok.indent < 0:
    # tkParLe is allowed for ``var (x, y) = ...`` tuple parsing
    # `tkKeywords` means an error case: we accept the unescaped keyword and
    # definition parsing is responsible for emitting an error diagnostic.
    result.add defparser(p)
  else:
    p.invalidExpectedIdent()

proc parseEnum(p: var Parser): ParsedNode =
  #| enumDecl = 'enum' optInd (symbol pragma? optInd ('=' optInd expr COMMENT?)? comma?)+
  result = p.newNodeConsumingTok(pnkEnumTy, @[p.emptyNode])
  p.optInd(result)
  p.flexComment(result)
  # progress guaranteed
  while true:
    let
      symTok = p.tok
      a = parseSymbol(p)
    if a.kind == pnkEmpty: return

    var symPragma = a
    if (p.tok.indent < 0 or p.tok.indent >= p.currInd) and p.tok.tokType == tkCurlyDotLe:
      let
        curlyTok = p.tok
        pragma = optPragmas(p)
      symPragma = p.newNode(pnkPragmaExpr, curlyTok, @[a, pragma])
    if p.tok.indent >= 0 and p.tok.indent <= p.currInd:
      result.add symPragma
      break

    if p.tok.tokType == tkEquals and p.tok.indent < 0:
      let eqTok = p.tok
      p.getTok
      p.optInd(symPragma)
      let b = symPragma
      symPragma = p.newNode(pnkEnumFieldDef, eqTok, @[b, p.parseExpr])
      if p.tok.indent < 0 or p.tok.indent >= p.currInd:
        p.rawSkipComment(symPragma)
    if p.tok.tokType == tkComma and p.tok.indent < 0:
      p.getTok
      p.rawSkipComment(symPragma)
    else:
      if p.tok.indent < 0 or p.tok.indent >= p.currInd:
        p.rawSkipComment(symPragma)
    result.add symPragma
    if p.tok.indent >= 0 and p.tok.indent <= p.currInd or
        p.tok.tokType == tkEof:
      break
  if result.len <= 1:
    p.invalidExpectedIdent()

proc parseObjectPart(p: var Parser): ParsedNode
proc parseObjectWhen(p: var Parser): ParsedNode =
  #| objectWhen = 'when' expr colcom objectPart COMMENT?
  #|             ('elif' expr colcom objectPart COMMENT?)*
  #|             ('else' colcom objectPart COMMENT?)?
  result = p.newNode(pnkRecWhen, p.tok)
  # progress guaranteed
  while p.sameInd:
    p.getTok                 # skip `when`, `elif`
    var branch = p.newNode(pnkElifBranch, p.tok)
    p.optInd(branch)
    branch.add parseExpr(p)
    p.colcom(branch)
    branch.add parseObjectPart(p)
    p.flexComment(branch)
    result.add branch
    if p.tok.tokType != tkElif: break
  if p.tok.tokType == tkElse and p.sameInd:
    var branch = p.newNodeConsumingTok(pnkElse)
    p.colcom(branch)
    branch.add parseObjectPart(p)
    p.flexComment(branch)
    result.add branch

proc parseObjectCase(p: var Parser): ParsedNode =
  #| objectBranch = 'of' exprList colcom objectPart
  #| objectBranches = objectBranch (IND{=} objectBranch)*
  #|                       (IND{=} 'elif' expr colcom objectPart)*
  #|                       (IND{=} 'else' colcom objectPart)?
  #| objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
  #|             (IND{>} objectBranches DED
  #|             | IND{=} objectBranches)
  result = p.newNode(pnkRecCase, p.tok)
  p.getTokNoInd
  var a = p.newNode(pnkIdentDefs, p.tok)
  a.add identWithPragma(p)
  p.eat(tkColon)
  a.add parseTypeDesc(p)
  a.add p.emptyNode
  result.add a
  if p.tok.tokType == tkColon: p.getTok
  p.flexComment(result)
  let
    oldInd = p.currInd
    wasIndented = p.realInd
  if wasIndented:
    p.currInd = p.tok.indent
  # progress guaranteed
  while p.sameInd:
    var b: ParsedNode
    case p.tok.tokType
    of tkOf:
      b = p.newNode(pnkOfBranch, p.tok)
      p.exprList(tkColon, b)
    of tkElse:
      b = p.newNodeConsumingTok(pnkElse)
    else: break
    p.colcom(b)
    var fields = parseObjectPart(p)
    if fields.kind == pnkEmpty:
      p.invalidExpectedIdent()
      fields = p.newNilLitNode(p.tok) # don't break further semantic checking
    b.add fields
    result.add b
    if b.kind == pnkElse: break
  if wasIndented:
    p.currInd = oldInd

proc parseObjectPart(p: var Parser): ParsedNode =
  #| objectPart = IND{>} objectPart^+IND{=} DED
  #|            / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
  if p.realInd:
    result = p.newNode(pnkRecList, p.tok)
    withInd(p):
      p.rawSkipComment(result)
      while p.sameInd:
        case p.tok.tokType
        of tkCase, tkWhen, tkSymbol, tkAccent, tkNil, tkDiscard:
          result.add parseObjectPart(p)
        else:
          p.invalidExpectedIdent()
          break
  elif p.sameOrNoInd:
    case p.tok.tokType
    of tkWhen:
      result = parseObjectWhen(p)
    of tkCase:
      result = parseObjectCase(p)
    of tkSymbol, tkAccent:
      result = p.parseIdentColonEquals({withPragma})
      if p.tok.indent < 0 or p.tok.indent >= p.currInd:
        p.rawSkipComment(result)
    of tkNil, tkDiscard:
      result = p.newNilLitNode(p.tok)
      p.getTok
    else:
      result = p.emptyNode
  else:
    result = p.emptyNode

proc parseObject(p: var Parser): ParsedNode =
  #| objectDecl = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
  result = p.newNodeConsumingTok(pnkObjectTy)
  result.add if p.tok.tokType == tkCurlyDotLe and p.validInd:
               # Deprecated: type declaration syntax needs overhaul to fix this
               p.currTokenDiag(pdkPragmaDoesNotFollowTypeName)
               p.parsePragma
             else:
               p.emptyNode
  result.add if p.tok.tokType == tkOf and p.tok.indent < 0:
               var a = p.newNodeConsumingTok(pnkOfInherit)
               a.add parseTypeDesc(p)
               a
             else:
               p.emptyNode
  if p.tok.tokType == tkComment:
    p.skipComment(result)
  # an initial IND{>} HAS to follow:
  result.add if p.realInd:
               parseObjectPart(p)
             else:
               p.emptyNode

proc parseTypeClassParam(p: var Parser): ParsedNode =
  let modifier =
    case p.tok.tokType
    of tkOut, tkVar: pnkVarTy
    of tkPtr:        pnkPtrTy
    of tkRef:        pnkRefTy
    of tkStatic:     pnkStaticTy
    of tkType:       pnkTypeOfExpr
    else:            pnkEmpty

  if modifier != pnkEmpty:
    result = p.newNodeConsumingTok(modifier)
    result.add p.parseSymbol
  else:
    result = p.parseSymbol

proc parseTypeClass(p: var Parser): ParsedNode =
  #| conceptParam = ('var' | 'out')? symbol
  #| conceptDecl = 'concept' conceptParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
  #|               &IND{>} stmt
  result = p.newNodeConsumingTok(pnkTypeClassTy)

  var args = p.newNode(pnkArgList, p.tok)
  result.add args
  args.add p.parseTypeClassParam
  while p.tok.tokType == tkComma:
    p.getTok
    args.add p.parseTypeClassParam

  result.add if p.tok.tokType == tkCurlyDotLe and p.validInd:
               parsePragma(p)
             else:
               p.emptyNode
  result.add if p.tok.tokType == tkOf and p.tok.indent < 0:
               var a = p.newNodeConsumingTok(pnkOfInherit)
               # progress guaranteed
               while true:
                 a.add parseTypeDesc(p)
                 if p.tok.tokType != tkComma: break
                 p.getTok
               a
             else:
               p.emptyNode
  if p.tok.tokType == tkComment:
    p.skipComment(result)
  # an initial IND{>} HAS to follow:
  result.add if p.realInd:
               parseStmt(p)
             else:
               p.emptyNode

proc parseTypeDef(p: var Parser): ParsedNode =
  #|
  #| typeDef = identWithPragmaDot '=' optInd typeDefAux
  #|             indAndComment? / identVisDot genericParamList? pragma? '=' optInd typeDefAux
  #|             indAndComment?
  result = p.newNode(pnkTypeDef, p.tok)
  let 
    identifier = p.identVis(allowDot=true)
    (genericParams, pragmas) =
      case p.tok.tokType
      of tkBracketLe:
        (
          (if p.validInd: parseGenericParamList(p) else: p.emptyNode),
          optPragmas(p)
        )
        # xxx: should the else/empty generic branch invalid indentation error?
      of tkCurlyDotLe:
        let res = (p.emptyNode, optPragmas(p))

        if p.validInd and p.tok.tokType == tkBracketLe:
          p.currTokenDiag(pdkPragmaBeforeGenericParameters)

        res
      of tkEquals:
        (p.emptyNode, p.emptyNode)
        # parsing for everything after the equals is shared, we do that below
      else:
        (p.emptyNode, p.emptyNode) # xxx: error?

  result.add:
    if pragmas.kind == pnkEmpty:
      identifier
    else:
      p.newNode(pnkPragmaExpr, pragmas.token, @[identifier, pragmas])
  result.add genericParams
  result.add case p.tok.tokType
             of tkEquals:
               result.token = toParsedToken(p.tok)
               p.getTok
               p.optInd(result)
               parseTypeDefAux(p)
             else:
               p.emptyNode
  p.indAndComment(result)    # special extension!

proc parseVarTuple(p: var Parser): ParsedNode =
  #| varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
  result = p.newNodeConsumingTok(pnkVarTuple) # '('
  p.optInd(result)
  # progress guaranteed
  while p.tok.tokType in {tkSymbol, tkAccent}:
    var a = p.identWithPragma(allowDot=true)
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.skipComment(a)
  result.add p.emptyNode         # no type desc
  p.optPar
  p.eat(tkParRi)

proc parseVariable(p: var Parser): ParsedNode =
  #| colonBody = colcom stmt postExprBlocks?
  #| variable = (varTuple / identColonEquals) colonBody? indAndComment
  if p.tok.tokType == tkParLe:
    result = parseVarTuple(p)
    p.eat(tkEquals)
    p.optInd(result)
    result.add parseExpr(p)
  else:
    result = p.parseIdentColonEquals({withPragma, withDot})
  result[^1] = p.postExprBlocks(result[^1])
  p.indAndComment(result)

proc parseConstant(p: var Parser): ParsedNode =
  #| constant = (varTuple / identWithPragma) (colon typeDesc)? '=' optInd expr indAndComment
  if p.tok.tokType == tkParLe:
    result = parseVarTuple(p)
  else:
    result = p.newNode(pnkConstDef, p.tok)
    result.add identWithPragma(p)
    if p.tok.tokType == tkColon:
      p.getTok
      p.optInd(result)
      result.add parseTypeDesc(p)
    else:
      result.add p.emptyNode
  p.eat(tkEquals)
  p.optInd(result)
  #add(result, parseStmtListExpr(p))
  result.add parseExpr(p)
  result[^1] = p.postExprBlocks(result[^1])
  p.indAndComment(result)

proc parseBind(p: var Parser, k: ParsedNodeKind): ParsedNode =
  #| bindStmt = 'bind' optInd qualifiedIdent ^+ comma
  #| mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
  result = p.newNodeConsumingTok(k)
  p.optInd(result)
  # progress guaranteed
  while true:
    var a = qualifiedIdent(p)
    result.add a
    if p.tok.tokType != tkComma: break
    p.getTok
    p.optInd(a)
  #expectNl(p)

proc parseStmtPragma(p: var Parser): ParsedNode =
  #| pragmaStmt = pragma (':' COMMENT? stmt)?
  result = parsePragma(p)
  if p.tok.tokType == tkColon and p.tok.indent < 0:
    let a = result
    result = p.newNode(pnkPragmaBlock, a.getToken)
    p.getTok
    p.skipComment(result)
    result.add a
    result.add parseStmt(p)

proc simpleStmt(p: var Parser): ParsedNode =
  #| simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
  #|            | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
  #|            | includeStmt | commentStmt) / exprStmt) COMMENT?
  #|
  result = case p.tok.tokType
           of tkReturn: p.parseReturnOrRaise(pnkReturnStmt)
           of tkRaise: p.parseReturnOrRaise(pnkRaiseStmt)
           of tkYield: p.parseReturnOrRaise(pnkYieldStmt)
           of tkDiscard: p.parseReturnOrRaise(pnkDiscardStmt)
           of tkBreak: p.parseReturnOrRaise(pnkBreakStmt)
           of tkContinue: p.parseReturnOrRaise(pnkContinueStmt)
           of tkCurlyDotLe: parseStmtPragma(p)
           of tkImport: p.parseImport(pnkImportStmt)
           of tkExport: p.parseImport(pnkExportStmt)
           of tkFrom: parseFromStmt(p)
           of tkInclude: parseIncludeStmt(p)
           of tkComment: newCommentStmt(p)
           elif isExprStart(p): parseExprStmt(p)
           else: p.emptyNode
  if result.kind notin {pnkEmpty, pnkCommentStmt}: p.skipComment(result)

proc complexOrSimpleStmt(p: var Parser): ParsedNode =
  #| complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
  #|                     | tryStmt | forStmt
  #|                     | blockStmt | staticStmt | deferStmt | asmStmt
  #|                     | 'proc' routine
  #|                     | 'method' routine
  #|                     | 'func' routine
  #|                     | 'iterator' routine
  #|                     | 'macro' routine
  #|                     | 'template' routine
  #|                     | 'converter' routine
  #|                     | 'type' section(typeDef)
  #|                     | 'const' section(constant)
  #|                     | ('let' | 'var' | 'using') section(variable)
  #|                     | bindStmt | mixinStmt)
  #|                     / simpleStmt
  case p.tok.tokType
  of tkIf: result = p.parseIfOrWhen(pnkIfStmt)
  of tkWhile: result = parseWhile(p)
  of tkCase: result = parseCase(p)
  of tkTry: result = p.parseTry(isExpr=false)
  of tkFinally: result = p.parseExceptBlock(pnkFinally)
  of tkExcept: result = p.parseExceptBlock(pnkExceptBranch)
  of tkFor: result = parseFor(p)
  of tkBlock: result = parseBlock(p)
  of tkStatic: result = p.parseStaticOrDefer(pnkStaticStmt)
  of tkDefer: result = p.parseStaticOrDefer(pnkDefer)
  of tkAsm: result = parseAsm(p)
  of tkProc: result = p.parseRoutine(pnkProcDef)
  of tkFunc: result = p.parseRoutine(pnkFuncDef)
  of tkMethod: result = p.parseRoutine(pnkMethodDef)
  of tkIterator: result = p.parseRoutine(pnkIteratorDef)
  of tkMacro: result = p.parseRoutine(pnkMacroDef)
  of tkTemplate: result = p.parseRoutine(pnkTemplateDef)
  of tkConverter: result = p.parseRoutine(pnkConverterDef)
  of tkType:
    let tyTok = p.tok
    p.getTok
    if p.tok.tokType == tkParLe:
      p.getTok
      result = p.newNode(pnkTypeOfExpr, tyTok)
      result.add p.primary(pmTypeDesc)
      p.eat(tkParRi)
      result = p.parseOperators(result, -1, pmNormal)
    else:
      result = p.parseSection(pnkTypeSection, parseTypeDef)
  of tkConst: result = p.parseSection(pnkConstSection, parseConstant)
  of tkLet: result = p.parseSection(pnkLetSection, parseVariable)
  of tkVar: result = p.parseSection(pnkVarSection, parseVariable)
  of tkWhen: result = p.parseIfOrWhen(pnkWhenStmt)
  of tkBind: result = p.parseBind(pnkBindStmt)
  of tkMixin: result = p.parseBind(pnkMixinStmt)
  of tkUsing: result = p.parseSection(pnkUsingStmt, parseVariable)
  else: result = simpleStmt(p)

proc parseStmt(p: var Parser): ParsedNode =
  #| stmt = (IND{>} complexOrSimpleStmt^+(IND{=} / ';') DED)
  #|      / simpleStmt ^+ ';'
  if p.realInd:
    result = p.newNode(pnkStmtList, p.tok)
    withInd(p):
      while true:
        if p.sameInd:
          discard
        elif p.tok.tokType == tkSemiColon:
          p.getTok
          if p.sameOrNoInd: discard
          else: break
        else:
          if p.realInd and p.tok.tokType != tkDot:
            p.invalidIndentation()
          break
        if p.tok.tokType in {tkCurlyRi, tkParRi, tkCurlyDotRi, tkBracketRi}:
          # XXX this ensures tnamedparamanonproc still compiles;
          # deprecate this syntax later
          break
        p.hasProgress = false
        if p.tok.tokType in {tkElse, tkElif}:
          break # Allow this too, see tests/parser/tifexprs

        let a = complexOrSimpleStmt(p)
        if a.kind == pnkEmpty and not p.hasProgress:
          p.invalidExpectedExpr()
          break
        else:
          result.add a

        if not p.hasProgress and p.tok.tokType == tkEof: break
  else:
    # the case statement is only needed for better error messages:
    case p.tok.tokType
    of tkIf, tkWhile, tkCase, tkTry, tkFor, tkBlock, tkAsm, tkProc, tkFunc,
       tkIterator, tkMacro, tkType, tkConst, tkWhen, tkVar:
      p.currTokenDiag(pdkNestableRequiresIndentation)
      result = p.emptyNode
    else:
      if p.inSemiStmtList > 0:
        result = simpleStmt(p)
        if result.kind == pnkEmpty:
          p.invalidExpectedExpr()
      else:
        result = p.newNode(pnkStmtList, p.tok)
        while true:
          if p.tok.indent >= 0:
            p.invalidIndentation()
          p.hasProgress = false
          let a = simpleStmt(p)
          let err = not p.hasProgress
          if a.kind == pnkEmpty:
            p.invalidExpectedExpr()
          result.add a
          if p.tok.tokType != tkSemiColon: break
          p.getTok
          if err and p.tok.tokType == tkEof: break

proc parseAll(p: var Parser): ParsedNode =
  ## Parses the rest of the input stream held by the parser into a ParsedNode.
  result = p.newNode(pnkStmtList, p.tok)
  while p.tok.tokType != tkEof:
    p.hasProgress = false
    var a = complexOrSimpleStmt(p)
    if a.kind != pnkEmpty and p.hasProgress:
      result.add a
    else:
      p.invalidExpectedExpr()
      # bugfix: consume a token here to prevent an endless loop:
      p.getTok
    if p.tok.indent != 0:
      p.invalidIndentation()

proc parseTopLevelStmt(p: var Parser): ParsedNode =
  ## Implements an iterator which, when called repeatedly, returns the next
  ## top-level statement or emptyNode if end of stream.
  result = p.emptyNode
  # progress guaranteed
  while true:
    if p.tok.indent != 0:
      if p.firstTok and p.tok.indent < 0: discard
      elif p.tok.tokType != tkSemiColon:
        # special casing for better error messages:
        if p.tok.tokType == tkOpr and p.tok.ident.s == "*":
          p.currTokenDiag(pdkMisplacedExport)
        else:
          p.invalidIndentation()
    p.firstTok = false
    case p.tok.tokType
    of tkSemiColon:
      p.getTok
      if p.tok.indent <= 0:
        discard
      else:
        p.invalidIndentation()
      p.firstTok = true
    of tkEof: break
    else:
      result = complexOrSimpleStmt(p)
      if result.kind == pnkEmpty:
        p.invalidExpectedExpr()
      break

proc parseString*(s: string; cache: IdentCache; config: ConfigRef;
                  filename: string = ""; line: int = 0): ParsedNode =
  ## Parses a string into an AST, returning the top node.
  ## `filename` and `line`, although optional, provide info so that the
  ## compiler can generate correct error messages referring to the original
  ## source.
  var stream = llStreamOpen(s)
  stream.lineOffset = line

  var parser: Parser
  openParser(parser, AbsoluteFile filename, stream, cache, config)

  result = parser.parseAll
  closeParser(parser)
